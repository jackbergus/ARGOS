

BOGUS {
    turns{magnitude:single,ordering:strict}
    roles{speaker,listener}
    players{min:2, max:undefined}
    player{id:Proposer,roles{speaker}}
    player{id:Evaluator,roles{listener}}

     // This is mainly to store the request: it might be renamed
    store { id: StackinteractionA, owner: shared, structure: stack, visibility : public   }

    // Players subscribing to the supplier to privde the information in broadcast
    store { id: PlayersinteractionA, owner: shared, structure: stack, visibility : public  }

    // Whether the player has already read the information from the broadcaster
    store { id: AlreadyReadinteractionA, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyinteractionA, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyAuthorinteractionA, owner: shared, structure: stack, visibility : public  }
      // This is mainly to store the request: it might be renamed
    store { id: StackinteractionB, owner: shared, structure: stack, visibility : public   }

    // Players subscribing to the supplier to privde the information in broadcast
    store { id: PlayersinteractionB, owner: shared, structure: stack, visibility : public  }

    // Whether the player has already read the information from the broadcaster
    store { id: AlreadyReadinteractionB, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyinteractionB, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyAuthorinteractionB, owner: shared, structure: stack, visibility : public  }
      // This is mainly to store the request: it might be renamed
    store { id: StackinteractionC, owner: shared, structure: stack, visibility : public   }

    // Players subscribing to the supplier to privde the information in broadcast
    store { id: PlayersinteractionC, owner: shared, structure: stack, visibility : public  }

    // Whether the player has already read the information from the broadcaster
    store { id: AlreadyReadinteractionC, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyinteractionC, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyAuthorinteractionC, owner: shared, structure: stack, visibility : public  }
    

    rule{id:StartingRule, scope:initial, {  move(add, next, SubscribeinteractionA, Evaluator)
     &  move(add, next, SubscribeinteractionB, Evaluator)
     &  move(add, next, SubscribeinteractionC, Evaluator)
     }}


          // First, someone can publish only if someone subscribed. This still allows other services to subscribe, and enables
          // the client to start publishing. Still, I can subscribe only if I haven’t done so yet.
          interaction { SubscribeinteractionA, { if { inspect(!in, {s}, PlayersinteractionA ) }  then {
                                               store(add, {s}, PlayersinteractionA, listener) &
                                                move(add, next, StartPublishinteractionA, $Proposer, Proposer) & move(add, next, SubscribeinteractionA, Evaluator)
 &  move(add, next, StartPublishinteractionB, $Proposer, Proposer) & move(add, next, SubscribeinteractionB, Evaluator)
 &  move(add, next, StartPublishinteractionC, $Proposer, Proposer) & move(add, next, SubscribeinteractionC, Evaluator)

                                           }
                                      }
                      }

          // The publisher stops all the subscribers to register and to do whatsoever operation, then, it starts adding the data
          interaction { StartPublishinteractionA, { move(delete, next, SubscribeinteractionA, $Evaluator, Evaluator) &
                                           move(add, next, PublishinteractionA, $Proposer, {p}, Proposer)
                                         }
                      }

          // Now, ARGA starts sending the data {d} to the services, that are going to reply to the data being passed with some
          //  data reply. This might have been better expressed with a while-true loop, but anyway, stating that the publisher shall
          // place in the stack as many arguments as the number of players, while allowing the players only to publish needs
          // to be enforced by the implementation of the communication library. Then, ARGA reads from {l} the complete list of
          // services being available.
          interaction { PublishinteractionA , {  if { magnitude(StackinteractionA, shared, smaller, PlayersinteractionA, shared) } then {
                                                store(add, {d}, StackinteractionA, listener) &
                                                move(add, next, PublishinteractionA, $Proposer, {d}, Proposer) &
                                                store(copy, {l}, PlayersinteractionA, listener)
                                           } else {
                                                move(add, next, ConsumeinteractionA, $Evaluator, Evaluator)
                                           }
                                     }
                      }



          // The service can consume {p} from ARGA only if it subscribed to this and if it hasn’t read yet
          interaction { ConsumeinteractionA , { if { inspect(!in, {s}, AlreadyReadinteractionA )  &
                                            inspect(in, {s}, PlayersinteractionA ) }  then {

                                                store(pop, {p}, StackinteractionA, listener) & // reading the data for me on the stack
                                                store(add, {s}, AlreadyReadinteractionA, listener) & // Setting myself as already read the data
                                                move(add, next, PushOutcomeinteractionA, $Evaluator, Evaluator) &
                                                move(add, next, ConsumeinteractionA, $Evaluator, Evaluator)
                                           }
                                     }
                      }


          // I can push the outcome of the computation only if the process was registered and if it already read the information provided by ARGA
          interaction { PushOutcomeinteractionA, {    if { inspect(in, {s}, PlayersinteractionA) &
                                                  inspect(in, {s}, AlreadyReadinteractionA ) } then {

                                                    store(add, {o}, ReplyinteractionA, listener) &
                                                    store(add, {s}, ReplyAuthorinteractionA, listener) &
                                                    // Action that will be done effectively only by the last subscriber
                                                    move(add, next, TestLastinteractionA, $Evaluator, Evaluator) &
                                                    move(add, next, PushOutcomeinteractionA, $Evaluator, Evaluator) &
                                                    move(add, next, ConsumeinteractionA, $Evaluator, Evaluator)
                                                }
                                        }
                      }


              // All the services providing their response to ARGA require to perform an additional action after pushing the data,
              // as the language does not allow to test for multiple conditions within the same interaction. The need for performing
              // this action then needs to be enforced in the implementation of the communication library
              interaction { TestLastinteractionA, { if { magnitude(PlayersinteractionA, shared, equal, ReplyAuthorinteractionA, shared) &
                                                magnitude(ReplyinteractionA, shared, equal, AlreadyReadinteractionA, shared) &
                                                magnitude(PlayersinteractionA, shared, equal, AlreadyReadinteractionA, shared) } then {

                                                      move(add, next, PopOutcomeinteractionA, $Proposer, Proposer)
                                              } else {
                                                                                            move(add, next, TestLastinteractionA, $Evaluator, Evaluator) &
                                                    move(add, next, TestLastinteractionA, $Evaluator, Evaluator) &
                                                    move(add, next, PushOutcomeinteractionA, $Evaluator, Evaluator) &
                                                    move(add, next, ConsumeinteractionA, $Evaluator, Evaluator)
                                              }
                                         }
                          }

          // This is the actual part where ARGA will obtain the answer from the broadcast request to all the services subscribed to action ||x||
          // ARGA will then pop all the responses {o} for the services {s} and will provide an association s->o at the library level.
          // After all of this is done, we have to clear all of the containers and allow the services to subscribe again to receive
          // requests from ARGA. This is the only way we can currently mitigate possible effects of service crash (just between different
          // runs of the requests)
          interaction { PopOutcomeinteractionA, { if { size(ReplyinteractionA, Proposer, !empty) &
                                              size(ReplyAuthorinteractionA, Proposer, !empty)  } then {

                                                 store(pop, {o}, ReplyinteractionA, speaker) &
                                                 store(pop, {s}, ReplyAuthorinteractionA, speaker) &
                                                 move(add, next, PopOutcomeinteractionA, $Evaluator, Proposer)
                                            } else {
                                                  // When I reach the maximum capacity, I enforce all the players to re-register if they
                                                  // want to subscribe to the next round, and allowing all the players to consume.
                                                  store(empty, PlayersinteractionA, listener) &
                                                  store(empty, AlreadyReadinteractionA, listener) &
                                                  store(empty, ReplyinteractionA, listener) &
                                                  store(empty, ReplyAuthorinteractionA, listener) &
                                                  store(empty, StackinteractionA, listener) &
                                                   move(add, next, SubscribeinteractionA, Evaluator)  &  move(add, next, SubscribeinteractionB, Evaluator)  &  move(add, next, SubscribeinteractionC, Evaluator)  // Going back to allowing the next process to subscribe itself
                                           }
                                       }
                       }




     
          // First, someone can publish only if someone subscribed. This still allows other services to subscribe, and enables
          // the client to start publishing. Still, I can subscribe only if I haven’t done so yet.
          interaction { SubscribeinteractionB, { if { inspect(!in, {s}, PlayersinteractionB ) }  then {
                                               store(add, {s}, PlayersinteractionB, listener) &
                                                move(add, next, StartPublishinteractionA, $Proposer, Proposer) & move(add, next, SubscribeinteractionA, Evaluator)
 &  move(add, next, StartPublishinteractionB, $Proposer, Proposer) & move(add, next, SubscribeinteractionB, Evaluator)
 &  move(add, next, StartPublishinteractionC, $Proposer, Proposer) & move(add, next, SubscribeinteractionC, Evaluator)

                                           }
                                      }
                      }

          // The publisher stops all the subscribers to register and to do whatsoever operation, then, it starts adding the data
          interaction { StartPublishinteractionB, { move(delete, next, SubscribeinteractionB, $Evaluator, Evaluator) &
                                           move(add, next, PublishinteractionB, $Proposer, {p}, Proposer)
                                         }
                      }

          // Now, ARGA starts sending the data {d} to the services, that are going to reply to the data being passed with some
          //  data reply. This might have been better expressed with a while-true loop, but anyway, stating that the publisher shall
          // place in the stack as many arguments as the number of players, while allowing the players only to publish needs
          // to be enforced by the implementation of the communication library. Then, ARGA reads from {l} the complete list of
          // services being available.
          interaction { PublishinteractionB , {  if { magnitude(StackinteractionB, shared, smaller, PlayersinteractionB, shared) } then {
                                                store(add, {d}, StackinteractionB, listener) &
                                                move(add, next, PublishinteractionB, $Proposer, {d}, Proposer) &
                                                store(copy, {l}, PlayersinteractionB, listener)
                                           } else {
                                                move(add, next, ConsumeinteractionB, $Evaluator, Evaluator)
                                           }
                                     }
                      }



          // The service can consume {p} from ARGA only if it subscribed to this and if it hasn’t read yet
          interaction { ConsumeinteractionB , { if { inspect(!in, {s}, AlreadyReadinteractionB )  &
                                            inspect(in, {s}, PlayersinteractionB ) }  then {

                                                store(pop, {p}, StackinteractionB, listener) & // reading the data for me on the stack
                                                store(add, {s}, AlreadyReadinteractionB, listener) & // Setting myself as already read the data
                                                move(add, next, PushOutcomeinteractionB, $Evaluator, Evaluator) &
                                                move(add, next, ConsumeinteractionB, $Evaluator, Evaluator)
                                           }
                                     }
                      }


          // I can push the outcome of the computation only if the process was registered and if it already read the information provided by ARGA
          interaction { PushOutcomeinteractionB, {    if { inspect(in, {s}, PlayersinteractionB) &
                                                  inspect(in, {s}, AlreadyReadinteractionB ) } then {

                                                    store(add, {o}, ReplyinteractionB, listener) &
                                                    store(add, {s}, ReplyAuthorinteractionB, listener) &
                                                    // Action that will be done effectively only by the last subscriber
                                                    move(add, next, TestLastinteractionB, $Evaluator, Evaluator) &
                                                    move(add, next, PushOutcomeinteractionB, $Evaluator, Evaluator) &
                                                    move(add, next, ConsumeinteractionB, $Evaluator, Evaluator)
                                                }
                                        }
                      }


              // All the services providing their response to ARGA require to perform an additional action after pushing the data,
              // as the language does not allow to test for multiple conditions within the same interaction. The need for performing
              // this action then needs to be enforced in the implementation of the communication library
              interaction { TestLastinteractionB, { if { magnitude(PlayersinteractionB, shared, equal, ReplyAuthorinteractionB, shared) &
                                                magnitude(ReplyinteractionB, shared, equal, AlreadyReadinteractionB, shared) &
                                                magnitude(PlayersinteractionB, shared, equal, AlreadyReadinteractionB, shared) } then {

                                                      move(add, next, PopOutcomeinteractionB, $Proposer, Proposer)
                                              } else {
                                                                                            move(add, next, TestLastinteractionB, $Evaluator, Evaluator) &
                                                    move(add, next, TestLastinteractionB, $Evaluator, Evaluator) &
                                                    move(add, next, PushOutcomeinteractionB, $Evaluator, Evaluator) &
                                                    move(add, next, ConsumeinteractionB, $Evaluator, Evaluator)
                                              }
                                         }
                          }

          // This is the actual part where ARGA will obtain the answer from the broadcast request to all the services subscribed to action ||x||
          // ARGA will then pop all the responses {o} for the services {s} and will provide an association s->o at the library level.
          // After all of this is done, we have to clear all of the containers and allow the services to subscribe again to receive
          // requests from ARGA. This is the only way we can currently mitigate possible effects of service crash (just between different
          // runs of the requests)
          interaction { PopOutcomeinteractionB, { if { size(ReplyinteractionB, Proposer, !empty) &
                                              size(ReplyAuthorinteractionB, Proposer, !empty)  } then {

                                                 store(pop, {o}, ReplyinteractionB, speaker) &
                                                 store(pop, {s}, ReplyAuthorinteractionB, speaker) &
                                                 move(add, next, PopOutcomeinteractionB, $Evaluator, Proposer)
                                            } else {
                                                  // When I reach the maximum capacity, I enforce all the players to re-register if they
                                                  // want to subscribe to the next round, and allowing all the players to consume.
                                                  store(empty, PlayersinteractionB, listener) &
                                                  store(empty, AlreadyReadinteractionB, listener) &
                                                  store(empty, ReplyinteractionB, listener) &
                                                  store(empty, ReplyAuthorinteractionB, listener) &
                                                  store(empty, StackinteractionB, listener) &
                                                   move(add, next, SubscribeinteractionA, Evaluator)  &  move(add, next, SubscribeinteractionB, Evaluator)  &  move(add, next, SubscribeinteractionC, Evaluator)  // Going back to allowing the next process to subscribe itself
                                           }
                                       }
                       }




     
          // First, someone can publish only if someone subscribed. This still allows other services to subscribe, and enables
          // the client to start publishing. Still, I can subscribe only if I haven’t done so yet.
          interaction { SubscribeinteractionC, { if { inspect(!in, {s}, PlayersinteractionC ) }  then {
                                               store(add, {s}, PlayersinteractionC, listener) &
                                                move(add, next, StartPublishinteractionA, $Proposer, Proposer) & move(add, next, SubscribeinteractionA, Evaluator)
 &  move(add, next, StartPublishinteractionB, $Proposer, Proposer) & move(add, next, SubscribeinteractionB, Evaluator)
 &  move(add, next, StartPublishinteractionC, $Proposer, Proposer) & move(add, next, SubscribeinteractionC, Evaluator)

                                           }
                                      }
                      }

          // The publisher stops all the subscribers to register and to do whatsoever operation, then, it starts adding the data
          interaction { StartPublishinteractionC, { move(delete, next, SubscribeinteractionC, $Evaluator, Evaluator) &
                                           move(add, next, PublishinteractionC, $Proposer, {p}, Proposer)
                                         }
                      }

          // Now, ARGA starts sending the data {d} to the services, that are going to reply to the data being passed with some
          //  data reply. This might have been better expressed with a while-true loop, but anyway, stating that the publisher shall
          // place in the stack as many arguments as the number of players, while allowing the players only to publish needs
          // to be enforced by the implementation of the communication library. Then, ARGA reads from {l} the complete list of
          // services being available.
          interaction { PublishinteractionC , {  if { magnitude(StackinteractionC, shared, smaller, PlayersinteractionC, shared) } then {
                                                store(add, {d}, StackinteractionC, listener) &
                                                move(add, next, PublishinteractionC, $Proposer, {d}, Proposer) &
                                                store(copy, {l}, PlayersinteractionC, listener)
                                           } else {
                                                move(add, next, ConsumeinteractionC, $Evaluator, Evaluator)
                                           }
                                     }
                      }



          // The service can consume {p} from ARGA only if it subscribed to this and if it hasn’t read yet
          interaction { ConsumeinteractionC , { if { inspect(!in, {s}, AlreadyReadinteractionC )  &
                                            inspect(in, {s}, PlayersinteractionC ) }  then {

                                                store(pop, {p}, StackinteractionC, listener) & // reading the data for me on the stack
                                                store(add, {s}, AlreadyReadinteractionC, listener) & // Setting myself as already read the data
                                                move(add, next, PushOutcomeinteractionC, $Evaluator, Evaluator) &
                                                move(add, next, ConsumeinteractionC, $Evaluator, Evaluator)
                                           }
                                     }
                      }


          // I can push the outcome of the computation only if the process was registered and if it already read the information provided by ARGA
          interaction { PushOutcomeinteractionC, {    if { inspect(in, {s}, PlayersinteractionC) &
                                                  inspect(in, {s}, AlreadyReadinteractionC ) } then {

                                                    store(add, {o}, ReplyinteractionC, listener) &
                                                    store(add, {s}, ReplyAuthorinteractionC, listener) &
                                                    // Action that will be done effectively only by the last subscriber
                                                    move(add, next, TestLastinteractionC, $Evaluator, Evaluator) &
                                                    move(add, next, PushOutcomeinteractionC, $Evaluator, Evaluator) &
                                                    move(add, next, ConsumeinteractionC, $Evaluator, Evaluator)
                                                }
                                        }
                      }


              // All the services providing their response to ARGA require to perform an additional action after pushing the data,
              // as the language does not allow to test for multiple conditions within the same interaction. The need for performing
              // this action then needs to be enforced in the implementation of the communication library
              interaction { TestLastinteractionC, { if { magnitude(PlayersinteractionC, shared, equal, ReplyAuthorinteractionC, shared) &
                                                magnitude(ReplyinteractionC, shared, equal, AlreadyReadinteractionC, shared) &
                                                magnitude(PlayersinteractionC, shared, equal, AlreadyReadinteractionC, shared) } then {

                                                      move(add, next, PopOutcomeinteractionC, $Proposer, Proposer)
                                              } else {
                                                                                            move(add, next, TestLastinteractionC, $Evaluator, Evaluator) &
                                                    move(add, next, TestLastinteractionC, $Evaluator, Evaluator) &
                                                    move(add, next, PushOutcomeinteractionC, $Evaluator, Evaluator) &
                                                    move(add, next, ConsumeinteractionC, $Evaluator, Evaluator)
                                              }
                                         }
                          }

          // This is the actual part where ARGA will obtain the answer from the broadcast request to all the services subscribed to action ||x||
          // ARGA will then pop all the responses {o} for the services {s} and will provide an association s->o at the library level.
          // After all of this is done, we have to clear all of the containers and allow the services to subscribe again to receive
          // requests from ARGA. This is the only way we can currently mitigate possible effects of service crash (just between different
          // runs of the requests)
          interaction { PopOutcomeinteractionC, { if { size(ReplyinteractionC, Proposer, !empty) &
                                              size(ReplyAuthorinteractionC, Proposer, !empty)  } then {

                                                 store(pop, {o}, ReplyinteractionC, speaker) &
                                                 store(pop, {s}, ReplyAuthorinteractionC, speaker) &
                                                 move(add, next, PopOutcomeinteractionC, $Evaluator, Proposer)
                                            } else {
                                                  // When I reach the maximum capacity, I enforce all the players to re-register if they
                                                  // want to subscribe to the next round, and allowing all the players to consume.
                                                  store(empty, PlayersinteractionC, listener) &
                                                  store(empty, AlreadyReadinteractionC, listener) &
                                                  store(empty, ReplyinteractionC, listener) &
                                                  store(empty, ReplyAuthorinteractionC, listener) &
                                                  store(empty, StackinteractionC, listener) &
                                                   move(add, next, SubscribeinteractionA, Evaluator)  &  move(add, next, SubscribeinteractionB, Evaluator)  &  move(add, next, SubscribeinteractionC, Evaluator)  // Going back to allowing the next process to subscribe itself
                                           }
                                       }
                       }





}
