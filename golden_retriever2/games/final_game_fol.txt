∀x∈{interactionA,interactionB,interactionC}.

game ≝⟪

BOGUS {
    turns{magnitude:single,ordering:strict}
    roles{speaker,listener}
    players{min:2, max:undefined}
    player{id:Proposer,roles{speaker}}
    player{id:Evaluator,roles{listener}}

    ⟦ // This is mainly to store the request: it might be renamed
    store { id: Stack‖x‖, owner: shared, structure: stack, visibility : public   }

    // Players subscribing to the supplier to privde the information in broadcast
    store { id: Players‖x‖, owner: shared, structure: stack, visibility : public  }

    // Whether the player has already read the information from the broadcaster
    store { id: AlreadyRead‖x‖, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: Reply‖x‖, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyAuthor‖x‖, owner: shared, structure: stack, visibility : public  }
    ⟧(" ")

    rule{id:StartingRule, scope:initial, { ⟦ move(add, next, Subscribe‖x‖, Evaluator)
    ⟧(" & ") }}

⟦
          // First, someone can publish only if someone subscribed. This still allows other services to subscribe, and enables
          // the client to start publishing. Still, I can subscribe only if I haven’t done so yet.
          interaction { Subscribe‖x‖, { if { inspect(!in, {s}, Players‖x‖ ) }  then {
                                               store(add, {s}, Players‖x‖, listener) &
                                               move(add, next, StartPublish‖x‖, $Proposer, Proposer) &
                                               move(add, next, Subscribe‖x‖, Evaluator)
                                           }
                                      }
                      }

          // The publisher stops all the subscribers to register and to do whatsoever operation, then, it starts adding the data
          interaction { StartPublish‖x‖, { move(delete, next, Subscribe‖x‖, $Evaluator, Evaluator) &
                                           move(add, next, Publish‖x‖, $Proposer, {p}, Proposer)
                                         }
                      }

          // Now, ARGA starts sending the data {d} to the services, that are going to reply to the data being passed with some
          //  data reply. This might have been better expressed with a while-true loop, but anyway, stating that the publisher shall
          // place in the stack as many arguments as the number of players, while allowing the players only to publish needs
          // to be enforced by the implementation of the communication library. Then, ARGA reads from {l} the complete list of
          // services being available.
          interaction { Publish‖x‖ , {  if { magnitude(Stack‖x‖, shared, smaller, Players‖x‖, shared) } then {
                                                store(add, {d}, Stack‖x‖, listener) &
                                                move(add, next, Publish‖x‖, $Proposer, {d}, Proposer) &
                                                store(copy, {l}, Players‖x‖, listener)
                                           } else {
                                                move(add, next, Consume‖x‖, $Evaluator, Evaluator)
                                           }
                                     }
                      }



          // The service can consume {p} from ARGA only if it subscribed to this and if it hasn’t read yet
          interaction { Consume‖x‖ , { if { inspect(!in, {s}, AlreadyRead‖x‖ )  &
                                            inspect(in, {s}, Players‖x‖ ) }  then {

                                                store(pop, {p}, Stack‖x‖, listener) & // reading the data for me on the stack
                                                store(add, {s}, AlreadyRead‖x‖, listener) & // Setting myself as already read the data
                                                move(add, next, PushOutcome‖x‖, $Evaluator, Evaluator) &
                                                move(add, next, Consume‖x‖, $Evaluator, Evaluator)
                                           }
                                     }
                      }


          // I can push the outcome of the computation only if the process was registered and if it already read the information provided by ARGA
          interaction { PushOutcome‖x‖, {    if { inspect(in, {s}, Players‖x‖) &
                                                  inspect(in, {s}, AlreadyRead‖x‖ ) } then {

                                                    store(add, {o}, Reply‖x‖, listener) &
                                                    store(add, {s}, ReplyAuthor‖x‖, listener) &
                                                    // Action that will be done effectively only by the last subscriber
                                                    move(add, next, TestLast‖x‖, $Evaluator, Evaluator) &
                                                    move(add, next, PushOutcome‖x‖, $Evaluator, Evaluator) &
                                                    move(add, next, Consume‖x‖, $Evaluator, Evaluator)
                                                }
                                        }
                      }


              // All the services providing their response to ARGA require to perform an additional action after pushing the data,
              // as the language does not allow to test for multiple conditions within the same interaction. The need for performing
              // this action then needs to be enforced in the implementation of the communication library
              interaction { TestLast‖x‖, { if { magnitude(Players‖x‖, shared, equal, ReplyAuthor‖x‖, shared) &
                                                magnitude(Reply‖x‖, shared, equal, AlreadyRead‖x‖, shared) &
                                                magnitude(Players‖x‖, shared, equal, AlreadyRead‖x‖, shared) } then {

                                                      move(add, next, PopOutcome‖x‖, $Proposer, Proposer)
                                              } else {
                                                                                            move(add, next, TestLast‖x‖, $Evaluator, Evaluator) &
                                                    move(add, next, TestLast‖x‖, $Evaluator, Evaluator) &
                                                    move(add, next, PushOutcome‖x‖, $Evaluator, Evaluator) &
                                                    move(add, next, Consume‖x‖, $Evaluator, Evaluator)
                                              }
                                         }
                          }

          // This is the actual part where ARGA will obtain the answer from the broadcast request to all the services subscribed to action ||x||
          // ARGA will then pop all the responses {o} for the services {s} and will provide an association s->o at the library level.
          // After all of this is done, we have to clear all of the containers and allow the services to subscribe again to receive
          // requests from ARGA. This is the only way we can currently mitigate possible effects of service crash (just between different
          // runs of the requests)
          interaction { PopOutcome‖x‖, { if { size(Reply‖x‖, Proposer, !empty) &
                                              size(ReplyAuthor‖x‖, Proposer, !empty)  } then {

                                                 store(pop, {o}, Reply‖x‖, speaker) &
                                                 store(pop, {s}, ReplyAuthor‖x‖, speaker) &
                                                 move(add, next, PopOutcome‖x‖, $Evaluator, Proposer)
                                            } else {
                                                  // When I reach the maximum capacity, I enforce all the players to re-register if they
                                                  // want to subscribe to the next round, and allowing all the players to consume.
                                                  store(empty, Players‖x‖, listener) &
                                                  store(empty, AlreadyRead‖x‖, listener) &
                                                  store(empty, Reply‖x‖, listener) &
                                                  store(empty, ReplyAuthor‖x‖, listener) &
                                                  store(empty, Stack‖x‖, listener) &
                                                  ⦃ move(add, next, Subscribe≪x≫, Evaluator) ⦄(" & ") // Going back to allowing the next process to subscribe itself
                                           }
                                       }
                       }




⟧("     ")
}
⟫
