

BOGUS {
    turns{magnitude:single,ordering:strict}
    roles{speaker,listener}
    players{min:2, max:undefined}
    player{id:Proposer,roles{speaker}}
    player{id:Evaluator,roles{listener}}

     // This is mainly to store the request: it might be renamed
    store { id: StackinteractionA, owner: shared, structure: stack, visibility : public   }

    // Players subscribing to the supplier to privde the information in broadcast
    store { id: PlayersinteractionA, owner: shared, structure: stack, visibility : public  }

    // Whether the player has already read the information from the broadcaster
    store { id: AlreadyReadinteractionA, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyinteractionA, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyAuthorinteractionA, owner: shared, structure: stack, visibility : public  }
      // This is mainly to store the request: it might be renamed
    store { id: StackinteractionB, owner: shared, structure: stack, visibility : public   }

    // Players subscribing to the supplier to privde the information in broadcast
    store { id: PlayersinteractionB, owner: shared, structure: stack, visibility : public  }

    // Whether the player has already read the information from the broadcaster
    store { id: AlreadyReadinteractionB, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyinteractionB, owner: shared, structure: stack, visibility : public  }

    // The reply associated to the player
    store { id: ReplyAuthorinteractionB, owner: shared, structure: stack, visibility : public  }
    

    rule{id:StartingRule, scope:initial, {  move(add, next, SubscribeinteractionA, Evaluator)
     &  move(add, next, SubscribeinteractionB, Evaluator)
     }}


    // First, someone can publish only if someone subscribed. This still allows other services to subscribe, and enables
    // the client to start publishing. Still, I can subscribe only if I haven’t done so yet.
    interaction { SubscribeinteractionA, { if { inspect(!in, {s}, PlayersinteractionA ) }  then {
                                                        move(add, next, StartPublishinteractionA, $Proposer, Proposer) &
                                                        store(add, {s}, PlayersinteractionA, listener) &
                                                        move(add, next, SubscribeinteractionA, Evaluator)
                                                       }
                                                  }
                       }

    // The publisher stops all the subscribers to register and to do whatsoever operation, then, it starts adding the data
    interaction { StartPublishinteractionA, { move(delete, next, SubscribeinteractionA, $Evaluator, Evaluator) &
                                                          move(add, next, PublishinteractionA, $Proposer, {p}, Proposer)
                                                       }
                      }

  // Now, the publisher starts sending the data to the subscribers, that are going to reply to the data being passed with some data reply
    // This might have been better expressed with a while-true loop, but anyway, expressing that the publisher shall
    // repeat in the stack as many arguments as the number of players, while allowing the players only to publish
    interaction { PublishinteractionA , {  if { magnitude(StackinteractionA, shared, smaller, PlayersinteractionA, shared) } then
                                                      { store(add, {d}, StackinteractionA, listener) &
                                                         move(add, next, PublishinteractionA, $Proposer, {d}, Proposer) }
                                                       else
                                                      { move(add, next, ConsumeinteractionA, $Evaluator, Evaluator)  }
                                               }
                         }



    // I can consume only if I was previously subscribed to this and if I haven’t read yet
    interaction { ConsumeinteractionA , {
                                                     if { inspect(!in, {s}, AlreadyReadinteractionA )  & inspect(!in, {s}, PlayersinteractionA ) }  then {
                                                         store(pop, {p}, StackinteractionA, listener) & // reading the data for me on the stack
                                                         store(add, {s}, AlreadyReadinteractionA, listener) & // Setting myself as already read the data
                                                         move(add, next, PushOutcomeinteractionA, $Evaluator, Evaluator) &
                                                         move(add, next, ConsumeinteractionA, $Evaluator, Evaluator)
                                                     }
                                                 }
                      }

    interaction { PushOutcomeinteractionA, {    if { inspect(in, {s}, PlayersinteractionA) & inspect(in, {s}, AlreadyReadinteractionA ) } then {
                                                                  store(add, {o}, ReplyinteractionA listener) &
                                                                  store(add, {s}, ReplyAuthorinteractionA, listener) &
                                                                  move(add, next, TestLastinteractionA, $Evaluator, Evaluator) // Action that will be done effectively only by the last subscriber
                                                              }
                                                         }
                       }

    interaction { PopOutcomeinteractionA, { if { size(ReplyinteractionA, Proposer, !empty) & size(ReplyAuthorinteractionA, Proposer, !empty)  } then {
                                                             store(pop, {o}, ReplyinteractionA, speaker) &
                                                             store(pop, {s}, ReplyAuthorinteractionA, speaker) &
                                                             move(add, next, PopOutcomeinteractionA, $Evaluator, Evaluator)
                                                       } else {
                                                            // When I reach the maximum capacity, I enforce all the players to re-register if they want to
                                                            // subscribe to the next round, and allowing all the players to consume.
                                                             store(empty, PlayersinteractionA, listener) &
                                                            store(empty, AlreadyReadinteractionA, listener) &
                                                            store(empty, ReplyinteractionA, listener) &
                                                            store(empty, ReplyAuthorinteractionA, listener) &
                                                            store(empty, StackinteractionA, listener) &
                                                             move(add, next, SubscribeinteractionA, Evaluator) // Going back to allowing the next process to subscribe itself
                                                        }
                                                      }
                   }

        interaction { TestLastinteractionA, { if { magnitude(PlayersinteractionA, shared, equal, ReplyAuthorinteractionA, shared) &
                                                            magnitude(ReplyinteractionA, shared, equal, AlreadyReadinteractionA, shared) } then {

                                                         move(add, next, PopOutcomeinteractionA, $Proposer, Proposer)
                                                      }
                                                    }
                           }


     
    // First, someone can publish only if someone subscribed. This still allows other services to subscribe, and enables
    // the client to start publishing. Still, I can subscribe only if I haven’t done so yet.
    interaction { SubscribeinteractionB, { if { inspect(!in, {s}, PlayersinteractionB ) }  then {
                                                        move(add, next, StartPublishinteractionB, $Proposer, Proposer) &
                                                        store(add, {s}, PlayersinteractionB, listener) &
                                                        move(add, next, SubscribeinteractionB, Evaluator)
                                                       }
                                                  }
                       }

    // The publisher stops all the subscribers to register and to do whatsoever operation, then, it starts adding the data
    interaction { StartPublishinteractionB, { move(delete, next, SubscribeinteractionB, $Evaluator, Evaluator) &
                                                          move(add, next, PublishinteractionB, $Proposer, {p}, Proposer)
                                                       }
                      }

  // Now, the publisher starts sending the data to the subscribers, that are going to reply to the data being passed with some data reply
    // This might have been better expressed with a while-true loop, but anyway, expressing that the publisher shall
    // repeat in the stack as many arguments as the number of players, while allowing the players only to publish
    interaction { PublishinteractionB , {  if { magnitude(StackinteractionB, shared, smaller, PlayersinteractionB, shared) } then
                                                      { store(add, {d}, StackinteractionB, listener) &
                                                         move(add, next, PublishinteractionB, $Proposer, {d}, Proposer) }
                                                       else
                                                      { move(add, next, ConsumeinteractionB, $Evaluator, Evaluator)  }
                                               }
                         }



    // I can consume only if I was previously subscribed to this and if I haven’t read yet
    interaction { ConsumeinteractionB , {
                                                     if { inspect(!in, {s}, AlreadyReadinteractionB )  & inspect(!in, {s}, PlayersinteractionB ) }  then {
                                                         store(pop, {p}, StackinteractionB, listener) & // reading the data for me on the stack
                                                         store(add, {s}, AlreadyReadinteractionB, listener) & // Setting myself as already read the data
                                                         move(add, next, PushOutcomeinteractionB, $Evaluator, Evaluator) &
                                                         move(add, next, ConsumeinteractionB, $Evaluator, Evaluator)
                                                     }
                                                 }
                      }

    interaction { PushOutcomeinteractionB, {    if { inspect(in, {s}, PlayersinteractionB) & inspect(in, {s}, AlreadyReadinteractionB ) } then {
                                                                  store(add, {o}, ReplyinteractionB listener) &
                                                                  store(add, {s}, ReplyAuthorinteractionB, listener) &
                                                                  move(add, next, TestLastinteractionB, $Evaluator, Evaluator) // Action that will be done effectively only by the last subscriber
                                                              }
                                                         }
                       }

    interaction { PopOutcomeinteractionB, { if { size(ReplyinteractionB, Proposer, !empty) & size(ReplyAuthorinteractionB, Proposer, !empty)  } then {
                                                             store(pop, {o}, ReplyinteractionB, speaker) &
                                                             store(pop, {s}, ReplyAuthorinteractionB, speaker) &
                                                             move(add, next, PopOutcomeinteractionB, $Evaluator, Evaluator)
                                                       } else {
                                                            // When I reach the maximum capacity, I enforce all the players to re-register if they want to
                                                            // subscribe to the next round, and allowing all the players to consume.
                                                             store(empty, PlayersinteractionB, listener) &
                                                            store(empty, AlreadyReadinteractionB, listener) &
                                                            store(empty, ReplyinteractionB, listener) &
                                                            store(empty, ReplyAuthorinteractionB, listener) &
                                                            store(empty, StackinteractionB, listener) &
                                                             move(add, next, SubscribeinteractionB, Evaluator) // Going back to allowing the next process to subscribe itself
                                                        }
                                                      }
                   }

        interaction { TestLastinteractionB, { if { magnitude(PlayersinteractionB, shared, equal, ReplyAuthorinteractionB, shared) &
                                                            magnitude(ReplyinteractionB, shared, equal, AlreadyReadinteractionB, shared) } then {

                                                         move(add, next, PopOutcomeinteractionB, $Proposer, Proposer)
                                                      }
                                                    }
                           }



}
