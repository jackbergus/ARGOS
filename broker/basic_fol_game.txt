

        BOGUS {
          turns{magnitude:single,ordering:strict}
          roles{speaker,listener}
          players{min:2, max:undefined}
          player{id:Proposer,roles{speaker}}
          player{id:Evaluator,roles{listener}}
      
           // This is mainly to store the request: it might be renamed
          store { id: StackinteractionA, owner: shared, structure: stack, visibility : public   }
      
          // Players subscribing to the supplier to privde the information in broadcast
          store { id: PlayersinteractionA, owner: shared, structure: stack, visibility : public  }
      
          // Whether the player has already read the information from the broadcaster
          store { id: AlreadyReadinteractionA, owner: shared, structure: stack, visibility : public  }
      
          // The reply associated to the player
          store { id: ReplyinteractionA, owner: shared, structure: stack, visibility : public  }
      
          // The reply associated to the player
          store { id: ReplyAuthorinteractionA, owner: shared, structure: stack, visibility : public  }
            // This is mainly to store the request: it might be renamed
          store { id: StackinteractionB, owner: shared, structure: stack, visibility : public   }
      
          // Players subscribing to the supplier to privde the information in broadcast
          store { id: PlayersinteractionB, owner: shared, structure: stack, visibility : public  }
      
          // Whether the player has already read the information from the broadcaster
          store { id: AlreadyReadinteractionB, owner: shared, structure: stack, visibility : public  }
      
          // The reply associated to the player
          store { id: ReplyinteractionB, owner: shared, structure: stack, visibility : public  }
      
          // The reply associated to the player
          store { id: ReplyAuthorinteractionB, owner: shared, structure: stack, visibility : public  }
          
      
          rule{id:StartingRule, scope:initial, {  move(add, next, SubscribeinteractionA, Evaluator)
           &  move(add, next, SubscribeinteractionB, Evaluator)
           }}
      
      
          // First, someone can publish only if someone subscribed. This still allows other services to subscribe, and enables
          // the client to start publishing. Still, I can subscribe only if I haven’t done so yet.
          interaction { SubscribeinteractionA, { if { inspect(!in, {s}, PlayersinteractionA ) }  then {
                                               store(add, {s}, PlayersinteractionA, listener) &
                                               move(add, next, StartPublishinteractionA, $Proposer, Proposer) &
                                               move(add, next, SubscribeinteractionA, Evaluator)
                                           }
                                      }
                      }
      
          // The publisher stops all the subscribers to register and to do whatsoever operation, then, it starts adding the data
          interaction { StartPublishinteractionA, { move(delete, next, SubscribeinteractionA, $Evaluator, Evaluator) &
                                           move(add, next, PublishinteractionA, $Proposer, {p}, Proposer)
                                         }
                      }
      
          // Now, the publisher starts sending the data to the subscribers, that are going to reply to the data being passed with some
          //  data replyThis might have been better expressed with a while-true loop, but anyway, expressing that the publisher shall
          // repeat in the stack as many arguments as the number of players, while allowing the players only to publish
          interaction { PublishinteractionA , {  if { magnitude(StackinteractionA, shared, smaller, PlayersinteractionA, shared) } then {
                                                store(add, {d}, StackinteractionA, listener) &
                                                move(add, next, PublishinteractionA, $Proposer, {d}, Proposer) &
                                                store(copy, {l}, PlayersinteractionA, listener)
                                           } else {
                                                move(add, next, ConsumeinteractionA, $Evaluator, Evaluator)
                                           }
                                     }
                      }
      
      
      
          // I can consume only if I was previously subscribed to this and if I haven’t read yet
          interaction { ConsumeinteractionA , { if { inspect(!in, {s}, AlreadyReadinteractionA )  &
                                            inspect(in, {s}, PlayersinteractionA ) }  then {
      
                                                store(pop, {p}, StackinteractionA, listener) & // reading the data for me on the stack
                                                store(add, {s}, AlreadyReadinteractionA, listener) & // Setting myself as already read the data
                                                move(add, next, PushOutcomeinteractionA, $Evaluator, Evaluator) &
                                                move(add, next, ConsumeinteractionA, $Evaluator, Evaluator)
                                           }
                                     }
                      }
      
          interaction { PushOutcomeinteractionA, {    if { inspect(in, {s}, PlayersinteractionA) &
                                                  inspect(in, {s}, AlreadyReadinteractionA ) } then {
      
                                                    store(add, {o}, ReplyinteractionA, listener) &
                                                    store(add, {s}, ReplyAuthorinteractionA, listener) &
                                                    // Action that will be done effectively only by the last subscriber
                                                    move(add, next, TestLastinteractionA, $Evaluator, Evaluator) &
                                                    move(add, next, PushOutcomeinteractionA, $Evaluator, Evaluator) &
                                                    move(add, next, ConsumeinteractionA, $Evaluator, Evaluator)
                                                }
                                        }
                      }
      
              interaction { TestLastinteractionA, { if { magnitude(PlayersinteractionA, shared, equal, ReplyAuthorinteractionA, shared) &
                                                magnitude(ReplyinteractionA, shared, equal, AlreadyReadinteractionA, shared) &
                                                magnitude(PlayersinteractionA, shared, equal, AlreadyReadinteractionA, shared) } then {
      
                                                      move(add, next, PopOutcomeinteractionA, $Proposer, Proposer)
                                              } else {
                                                                                            move(add, next, TestLastinteractionA, $Evaluator, Evaluator) &
                                                    move(add, next, TestLastinteractionA, $Evaluator, Evaluator) &
                                                    move(add, next, PushOutcomeinteractionA, $Evaluator, Evaluator) &
                                                    move(add, next, ConsumeinteractionA, $Evaluator, Evaluator)
                                              }
                                         }
                          }
      
          interaction { PopOutcomeinteractionA, { if { size(ReplyinteractionA, Proposer, !empty) &
                                              size(ReplyAuthorinteractionA, Proposer, !empty)  } then {
      
                                                 store(pop, {o}, ReplyinteractionA, speaker) &
                                                 store(pop, {s}, ReplyAuthorinteractionA, speaker) &
                                                 move(add, next, PopOutcomeinteractionA, $Evaluator, Proposer)
                                            } else {
                                                  // When I reach the maximum capacity, I enforce all the players to re-register if they
                                                  // want to subscribe to the next round, and allowing all the players to consume.
                                                  store(empty, PlayersinteractionA, listener) &
                                                  store(empty, AlreadyReadinteractionA, listener) &
                                                  store(empty, ReplyinteractionA, listener) &
                                                  store(empty, ReplyAuthorinteractionA, listener) &
                                                  store(empty, StackinteractionA, listener) &
                                                  move(add, next, SubscribeinteractionA, Evaluator) // Going back to allowing the next process to subscribe itself
                                           }
                                       }
                       }
      }
