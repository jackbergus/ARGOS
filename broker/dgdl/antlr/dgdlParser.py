# Generated from dgdl/antlr/dgdl.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,108,819,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,1,0,1,
        0,1,0,4,0,186,8,0,11,0,12,0,187,1,0,1,0,1,1,1,1,1,2,1,2,1,2,1,2,
        5,2,198,8,2,10,2,12,2,201,9,2,1,2,4,2,204,8,2,11,2,12,2,205,1,2,
        1,2,1,3,1,3,1,4,1,4,3,4,214,8,4,1,4,1,4,4,4,218,8,4,11,4,12,4,219,
        1,4,5,4,223,8,4,10,4,12,4,226,9,4,1,4,5,4,229,8,4,10,4,12,4,232,
        9,4,1,4,3,4,235,8,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,244,8,5,1,5,
        1,5,1,6,1,6,1,6,1,6,1,6,3,6,253,8,6,1,7,1,7,1,7,1,7,1,8,1,8,1,8,
        1,8,1,8,3,8,264,8,8,1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,5,10,
        275,8,10,10,10,12,10,278,9,10,1,10,1,10,1,11,1,11,1,11,3,11,285,
        8,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,13,
        1,13,1,14,1,14,3,14,302,8,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,
        3,15,311,8,15,1,15,1,15,1,16,1,16,3,16,317,8,16,1,17,1,17,1,17,1,
        17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,19,1,19,1,20,1,
        20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,
        20,5,20,349,8,20,10,20,12,20,352,9,20,1,20,1,20,1,21,1,21,1,22,1,
        22,1,22,1,22,1,22,4,22,363,8,22,11,22,12,22,364,1,22,1,22,1,22,3,
        22,370,8,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,1,25,1,25,1,
        25,1,25,1,25,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,
        26,1,26,1,26,1,27,1,27,1,28,1,28,1,29,1,29,3,29,404,8,29,1,30,1,
        30,1,30,1,30,5,30,410,8,30,10,30,12,30,413,9,30,1,30,1,30,1,31,1,
        31,1,31,1,31,1,31,3,31,422,8,31,1,32,1,32,1,32,1,32,3,32,428,8,32,
        1,33,1,33,1,33,1,33,5,33,434,8,33,10,33,12,33,437,9,33,1,33,1,33,
        1,34,1,34,1,34,3,34,444,8,34,1,35,1,35,1,36,3,36,449,8,36,1,36,1,
        36,1,37,1,37,1,38,1,38,1,38,1,38,1,38,1,38,5,38,461,8,38,10,38,12,
        38,464,9,38,1,38,3,38,467,8,38,1,38,1,38,1,39,1,39,1,39,1,39,1,39,
        1,40,1,40,1,40,1,41,1,41,1,41,1,41,5,41,483,8,41,10,41,12,41,486,
        9,41,1,41,1,41,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,
        3,42,500,8,42,1,43,1,43,1,43,1,43,1,43,3,43,507,8,43,1,43,1,43,3,
        43,511,8,43,1,43,1,43,5,43,515,8,43,10,43,12,43,518,9,43,1,43,1,
        43,3,43,522,8,43,1,43,1,43,1,43,1,43,1,44,1,44,1,44,1,45,1,45,1,
        45,1,45,1,45,1,45,1,45,3,45,538,8,45,1,46,1,46,1,46,1,46,1,46,1,
        46,1,47,1,47,1,47,1,47,1,48,1,48,1,49,1,49,1,50,1,50,1,50,1,50,1,
        50,1,50,1,50,3,50,561,8,50,1,50,1,50,3,50,565,8,50,1,50,1,50,3,50,
        569,8,50,1,50,1,50,1,51,1,51,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,3,52,584,8,52,1,52,1,52,3,52,588,8,52,1,52,1,52,1,53,1,
        53,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,55,1,55,1,55,1,55,1,55,1,
        55,1,55,1,55,1,55,1,56,1,56,3,56,612,8,56,1,57,1,57,1,58,1,58,1,
        58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,59,1,59,1,
        60,1,60,1,61,1,61,3,61,635,8,61,1,62,1,62,1,63,1,63,3,63,641,8,63,
        1,64,1,64,1,64,1,64,1,64,1,64,3,64,649,8,64,1,64,1,64,1,65,1,65,
        1,65,1,65,1,65,1,65,1,65,1,66,1,66,1,66,1,66,3,66,664,8,66,1,66,
        1,66,1,66,1,66,1,66,3,66,671,8,66,1,66,1,66,1,67,1,67,1,67,1,67,
        1,67,1,68,1,68,1,68,1,68,1,68,1,68,1,68,5,68,687,8,68,10,68,12,68,
        690,9,68,1,68,1,68,1,68,1,69,1,69,1,70,1,70,1,71,1,71,1,71,3,71,
        702,8,71,1,72,1,72,1,72,1,72,1,72,1,72,1,73,1,73,1,73,1,73,1,73,
        1,73,1,74,1,74,1,74,1,74,5,74,720,8,74,10,74,12,74,723,9,74,1,74,
        1,74,1,75,1,75,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,1,76,3,76,
        738,8,76,1,76,1,76,3,76,742,8,76,1,76,1,76,3,76,746,8,76,1,76,1,
        76,3,76,750,8,76,1,76,1,76,1,77,1,77,1,78,1,78,1,79,1,79,1,79,1,
        79,1,79,5,79,763,8,79,10,79,12,79,766,9,79,1,79,1,79,3,79,770,8,
        79,1,79,1,79,1,79,1,79,1,79,1,80,1,80,1,81,1,81,1,81,1,81,1,81,1,
        81,1,81,1,82,1,82,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,84,1,84,1,
        84,1,84,1,84,5,84,800,8,84,10,84,12,84,803,9,84,1,84,1,84,1,85,1,
        85,1,86,1,86,1,87,1,87,1,88,1,88,1,89,1,89,1,90,1,90,1,90,0,0,91,
        0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,
        46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,
        90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,
        126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,
        158,160,162,164,166,168,170,172,174,176,178,180,0,15,2,0,56,56,94,
        94,3,0,79,79,85,85,91,91,1,0,77,78,2,0,68,68,70,70,3,0,48,48,63,
        63,101,101,2,0,53,54,73,74,3,0,27,27,48,48,74,74,3,0,44,45,69,70,
        98,99,2,0,7,7,31,32,3,0,33,34,40,40,89,89,2,0,23,23,104,104,2,0,
        21,21,28,28,2,0,39,39,65,65,4,0,2,4,21,21,32,32,81,81,5,0,20,20,
        25,25,46,47,49,49,96,96,802,0,182,1,0,0,0,2,191,1,0,0,0,4,193,1,
        0,0,0,6,209,1,0,0,0,8,211,1,0,0,0,10,236,1,0,0,0,12,247,1,0,0,0,
        14,254,1,0,0,0,16,258,1,0,0,0,18,265,1,0,0,0,20,269,1,0,0,0,22,284,
        1,0,0,0,24,286,1,0,0,0,26,297,1,0,0,0,28,301,1,0,0,0,30,303,1,0,
        0,0,32,316,1,0,0,0,34,318,1,0,0,0,36,329,1,0,0,0,38,331,1,0,0,0,
        40,333,1,0,0,0,42,355,1,0,0,0,44,369,1,0,0,0,46,371,1,0,0,0,48,375,
        1,0,0,0,50,379,1,0,0,0,52,384,1,0,0,0,54,397,1,0,0,0,56,399,1,0,
        0,0,58,403,1,0,0,0,60,405,1,0,0,0,62,421,1,0,0,0,64,427,1,0,0,0,
        66,429,1,0,0,0,68,443,1,0,0,0,70,445,1,0,0,0,72,448,1,0,0,0,74,452,
        1,0,0,0,76,454,1,0,0,0,78,470,1,0,0,0,80,475,1,0,0,0,82,478,1,0,
        0,0,84,499,1,0,0,0,86,501,1,0,0,0,88,527,1,0,0,0,90,537,1,0,0,0,
        92,539,1,0,0,0,94,545,1,0,0,0,96,549,1,0,0,0,98,551,1,0,0,0,100,
        553,1,0,0,0,102,572,1,0,0,0,104,574,1,0,0,0,106,591,1,0,0,0,108,
        593,1,0,0,0,110,600,1,0,0,0,112,611,1,0,0,0,114,613,1,0,0,0,116,
        615,1,0,0,0,118,628,1,0,0,0,120,630,1,0,0,0,122,634,1,0,0,0,124,
        636,1,0,0,0,126,640,1,0,0,0,128,642,1,0,0,0,130,652,1,0,0,0,132,
        659,1,0,0,0,134,674,1,0,0,0,136,679,1,0,0,0,138,694,1,0,0,0,140,
        696,1,0,0,0,142,701,1,0,0,0,144,703,1,0,0,0,146,709,1,0,0,0,148,
        715,1,0,0,0,150,726,1,0,0,0,152,728,1,0,0,0,154,753,1,0,0,0,156,
        755,1,0,0,0,158,757,1,0,0,0,160,776,1,0,0,0,162,778,1,0,0,0,164,
        785,1,0,0,0,166,787,1,0,0,0,168,794,1,0,0,0,170,806,1,0,0,0,172,
        808,1,0,0,0,174,810,1,0,0,0,176,812,1,0,0,0,178,814,1,0,0,0,180,
        816,1,0,0,0,182,183,3,2,1,0,183,185,5,15,0,0,184,186,3,4,2,0,185,
        184,1,0,0,0,186,187,1,0,0,0,187,185,1,0,0,0,187,188,1,0,0,0,188,
        189,1,0,0,0,189,190,5,16,0,0,190,1,1,0,0,0,191,192,3,178,89,0,192,
        3,1,0,0,0,193,194,3,6,3,0,194,195,5,15,0,0,195,199,3,8,4,0,196,198,
        3,52,26,0,197,196,1,0,0,0,198,201,1,0,0,0,199,197,1,0,0,0,199,200,
        1,0,0,0,200,203,1,0,0,0,201,199,1,0,0,0,202,204,3,86,43,0,203,202,
        1,0,0,0,204,205,1,0,0,0,205,203,1,0,0,0,205,206,1,0,0,0,206,207,
        1,0,0,0,207,208,5,16,0,0,208,5,1,0,0,0,209,210,3,178,89,0,210,7,
        1,0,0,0,211,213,3,10,5,0,212,214,3,20,10,0,213,212,1,0,0,0,213,214,
        1,0,0,0,214,215,1,0,0,0,215,217,3,24,12,0,216,218,3,30,15,0,217,
        216,1,0,0,0,218,219,1,0,0,0,219,217,1,0,0,0,219,220,1,0,0,0,220,
        224,1,0,0,0,221,223,3,34,17,0,222,221,1,0,0,0,223,226,1,0,0,0,224,
        222,1,0,0,0,224,225,1,0,0,0,225,230,1,0,0,0,226,224,1,0,0,0,227,
        229,3,40,20,0,228,227,1,0,0,0,229,232,1,0,0,0,230,228,1,0,0,0,230,
        231,1,0,0,0,231,234,1,0,0,0,232,230,1,0,0,0,233,235,3,50,25,0,234,
        233,1,0,0,0,234,235,1,0,0,0,235,9,1,0,0,0,236,237,5,100,0,0,237,
        238,5,15,0,0,238,239,3,12,6,0,239,240,5,11,0,0,240,243,3,14,7,0,
        241,242,5,11,0,0,242,244,3,16,8,0,243,241,1,0,0,0,243,244,1,0,0,
        0,244,245,1,0,0,0,245,246,5,16,0,0,246,11,1,0,0,0,247,248,5,58,0,
        0,248,252,5,12,0,0,249,253,3,180,90,0,250,253,5,87,0,0,251,253,5,
        64,0,0,252,249,1,0,0,0,252,250,1,0,0,0,252,251,1,0,0,0,253,13,1,
        0,0,0,254,255,5,71,0,0,255,256,5,12,0,0,256,257,7,0,0,0,257,15,1,
        0,0,0,258,259,5,60,0,0,259,263,5,12,0,0,260,264,3,180,90,0,261,264,
        3,18,9,0,262,264,5,102,0,0,263,260,1,0,0,0,263,261,1,0,0,0,263,262,
        1,0,0,0,264,17,1,0,0,0,265,266,5,17,0,0,266,267,3,178,89,0,267,268,
        5,17,0,0,268,19,1,0,0,0,269,270,5,82,0,0,270,271,5,15,0,0,271,276,
        3,22,11,0,272,273,5,11,0,0,273,275,3,22,11,0,274,272,1,0,0,0,275,
        278,1,0,0,0,276,274,1,0,0,0,276,277,1,0,0,0,277,279,1,0,0,0,278,
        276,1,0,0,0,279,280,5,16,0,0,280,21,1,0,0,0,281,285,5,57,0,0,282,
        285,5,90,0,0,283,285,3,178,89,0,284,281,1,0,0,0,284,282,1,0,0,0,
        284,283,1,0,0,0,285,23,1,0,0,0,286,287,5,76,0,0,287,288,5,15,0,0,
        288,289,5,61,0,0,289,290,5,12,0,0,290,291,3,26,13,0,291,292,5,11,
        0,0,292,293,5,59,0,0,293,294,5,12,0,0,294,295,3,28,14,0,295,296,
        5,16,0,0,296,25,1,0,0,0,297,298,3,180,90,0,298,27,1,0,0,0,299,302,
        3,180,90,0,300,302,5,102,0,0,301,299,1,0,0,0,301,300,1,0,0,0,302,
        29,1,0,0,0,303,304,5,75,0,0,304,305,5,15,0,0,305,306,5,42,0,0,306,
        307,5,12,0,0,307,310,3,32,16,0,308,309,5,11,0,0,309,311,3,20,10,
        0,310,308,1,0,0,0,310,311,1,0,0,0,311,312,1,0,0,0,312,313,5,16,0,
        0,313,31,1,0,0,0,314,317,3,178,89,0,315,317,3,18,9,0,316,314,1,0,
        0,0,316,315,1,0,0,0,317,33,1,0,0,0,318,319,5,38,0,0,319,320,5,15,
        0,0,320,321,5,42,0,0,321,322,5,12,0,0,322,323,3,36,18,0,323,324,
        5,11,0,0,324,325,5,1,0,0,325,326,5,12,0,0,326,327,3,38,19,0,327,
        328,5,16,0,0,328,35,1,0,0,0,329,330,3,178,89,0,330,37,1,0,0,0,331,
        332,5,105,0,0,332,39,1,0,0,0,333,334,5,93,0,0,334,335,5,15,0,0,335,
        336,5,42,0,0,336,337,5,12,0,0,337,338,3,42,21,0,338,339,5,11,0,0,
        339,340,5,72,0,0,340,341,5,12,0,0,341,342,3,44,22,0,342,343,5,11,
        0,0,343,344,3,46,23,0,344,345,5,11,0,0,345,350,3,48,24,0,346,347,
        5,11,0,0,347,349,3,66,33,0,348,346,1,0,0,0,349,352,1,0,0,0,350,348,
        1,0,0,0,350,351,1,0,0,0,351,353,1,0,0,0,352,350,1,0,0,0,353,354,
        5,16,0,0,354,41,1,0,0,0,355,356,3,178,89,0,356,43,1,0,0,0,357,370,
        3,32,16,0,358,359,5,15,0,0,359,362,3,32,16,0,360,361,5,11,0,0,361,
        363,3,32,16,0,362,360,1,0,0,0,363,364,1,0,0,0,364,362,1,0,0,0,364,
        365,1,0,0,0,365,366,1,0,0,0,366,367,5,16,0,0,367,370,1,0,0,0,368,
        370,5,86,0,0,369,357,1,0,0,0,369,358,1,0,0,0,369,368,1,0,0,0,370,
        45,1,0,0,0,371,372,5,95,0,0,372,373,5,12,0,0,373,374,7,1,0,0,374,
        47,1,0,0,0,375,376,5,103,0,0,376,377,5,12,0,0,377,378,7,2,0,0,378,
        49,1,0,0,0,379,380,5,24,0,0,380,381,5,15,0,0,381,382,7,3,0,0,382,
        383,5,16,0,0,383,51,1,0,0,0,384,385,5,83,0,0,385,386,5,15,0,0,386,
        387,5,42,0,0,387,388,5,12,0,0,388,389,3,54,27,0,389,390,5,11,0,0,
        390,391,5,84,0,0,391,392,5,12,0,0,392,393,3,56,28,0,393,394,5,11,
        0,0,394,395,3,58,29,0,395,396,5,16,0,0,396,53,1,0,0,0,397,398,3,
        178,89,0,398,55,1,0,0,0,399,400,7,4,0,0,400,57,1,0,0,0,401,404,3,
        60,30,0,402,404,3,76,38,0,403,401,1,0,0,0,403,402,1,0,0,0,404,59,
        1,0,0,0,405,406,5,15,0,0,406,411,3,62,31,0,407,408,5,18,0,0,408,
        410,3,62,31,0,409,407,1,0,0,0,410,413,1,0,0,0,411,409,1,0,0,0,411,
        412,1,0,0,0,412,414,1,0,0,0,413,411,1,0,0,0,414,415,5,16,0,0,415,
        61,1,0,0,0,416,422,3,152,76,0,417,422,3,158,79,0,418,422,3,162,81,
        0,419,422,3,166,83,0,420,422,3,168,84,0,421,416,1,0,0,0,421,417,
        1,0,0,0,421,418,1,0,0,0,421,419,1,0,0,0,421,420,1,0,0,0,422,63,1,
        0,0,0,423,428,3,178,89,0,424,428,3,70,35,0,425,428,3,72,36,0,426,
        428,5,41,0,0,427,423,1,0,0,0,427,424,1,0,0,0,427,425,1,0,0,0,427,
        426,1,0,0,0,428,65,1,0,0,0,429,430,5,15,0,0,430,435,3,68,34,0,431,
        432,5,11,0,0,432,434,3,68,34,0,433,431,1,0,0,0,434,437,1,0,0,0,435,
        433,1,0,0,0,435,436,1,0,0,0,436,438,1,0,0,0,437,435,1,0,0,0,438,
        439,5,16,0,0,439,67,1,0,0,0,440,444,3,70,35,0,441,444,3,72,36,0,
        442,444,3,74,37,0,443,440,1,0,0,0,443,441,1,0,0,0,443,442,1,0,0,
        0,444,69,1,0,0,0,445,446,3,174,87,0,446,71,1,0,0,0,447,449,5,66,
        0,0,448,447,1,0,0,0,448,449,1,0,0,0,449,450,1,0,0,0,450,451,3,176,
        88,0,451,73,1,0,0,0,452,453,5,105,0,0,453,75,1,0,0,0,454,455,5,15,
        0,0,455,456,5,43,0,0,456,457,3,82,41,0,457,458,5,97,0,0,458,462,
        3,60,30,0,459,461,3,78,39,0,460,459,1,0,0,0,461,464,1,0,0,0,462,
        460,1,0,0,0,462,463,1,0,0,0,463,466,1,0,0,0,464,462,1,0,0,0,465,
        467,3,80,40,0,466,465,1,0,0,0,466,467,1,0,0,0,467,468,1,0,0,0,468,
        469,5,16,0,0,469,77,1,0,0,0,470,471,5,30,0,0,471,472,3,82,41,0,472,
        473,5,97,0,0,473,474,3,60,30,0,474,79,1,0,0,0,475,476,5,29,0,0,476,
        477,3,60,30,0,477,81,1,0,0,0,478,479,5,15,0,0,479,484,3,84,42,0,
        480,481,5,18,0,0,481,483,3,84,42,0,482,480,1,0,0,0,483,486,1,0,0,
        0,484,482,1,0,0,0,484,485,1,0,0,0,485,487,1,0,0,0,486,484,1,0,0,
        0,487,488,5,16,0,0,488,83,1,0,0,0,489,500,3,100,50,0,490,500,3,104,
        52,0,491,500,3,108,54,0,492,500,3,110,55,0,493,500,3,116,58,0,494,
        500,3,128,64,0,495,500,3,130,65,0,496,500,3,132,66,0,497,500,3,134,
        67,0,498,500,3,136,68,0,499,489,1,0,0,0,499,490,1,0,0,0,499,491,
        1,0,0,0,499,492,1,0,0,0,499,493,1,0,0,0,499,494,1,0,0,0,499,495,
        1,0,0,0,499,496,1,0,0,0,499,497,1,0,0,0,499,498,1,0,0,0,500,85,1,
        0,0,0,501,502,5,52,0,0,502,503,5,15,0,0,503,506,3,170,85,0,504,505,
        5,11,0,0,505,507,3,88,44,0,506,504,1,0,0,0,506,507,1,0,0,0,507,510,
        1,0,0,0,508,509,5,11,0,0,509,511,3,90,45,0,510,508,1,0,0,0,510,511,
        1,0,0,0,511,516,1,0,0,0,512,513,5,11,0,0,513,515,3,94,47,0,514,512,
        1,0,0,0,515,518,1,0,0,0,516,514,1,0,0,0,516,517,1,0,0,0,517,521,
        1,0,0,0,518,516,1,0,0,0,519,520,5,11,0,0,520,522,3,98,49,0,521,519,
        1,0,0,0,521,522,1,0,0,0,522,523,1,0,0,0,523,524,5,11,0,0,524,525,
        3,58,29,0,525,526,5,16,0,0,526,87,1,0,0,0,527,528,5,17,0,0,528,529,
        3,178,89,0,529,89,1,0,0,0,530,538,3,66,33,0,531,532,5,15,0,0,532,
        533,3,92,46,0,533,534,5,11,0,0,534,535,3,140,70,0,535,536,5,16,0,
        0,536,538,1,0,0,0,537,530,1,0,0,0,537,531,1,0,0,0,538,91,1,0,0,0,
        539,540,5,9,0,0,540,541,3,66,33,0,541,542,5,11,0,0,542,543,3,66,
        33,0,543,544,5,10,0,0,544,93,1,0,0,0,545,546,3,96,48,0,546,547,5,
        11,0,0,547,548,3,90,45,0,548,95,1,0,0,0,549,550,3,178,89,0,550,97,
        1,0,0,0,551,552,5,105,0,0,552,99,1,0,0,0,553,554,5,35,0,0,554,555,
        5,13,0,0,555,556,3,102,51,0,556,557,5,11,0,0,557,560,3,170,85,0,
        558,559,5,11,0,0,559,561,3,66,33,0,560,558,1,0,0,0,560,561,1,0,0,
        0,561,564,1,0,0,0,562,563,5,11,0,0,563,565,3,138,69,0,564,562,1,
        0,0,0,564,565,1,0,0,0,565,568,1,0,0,0,566,567,5,11,0,0,567,569,3,
        82,41,0,568,566,1,0,0,0,568,569,1,0,0,0,569,570,1,0,0,0,570,571,
        5,14,0,0,571,101,1,0,0,0,572,573,7,5,0,0,573,103,1,0,0,0,574,575,
        5,51,0,0,575,576,5,13,0,0,576,577,3,106,53,0,577,578,5,11,0,0,578,
        579,3,142,71,0,579,580,5,11,0,0,580,583,3,42,21,0,581,582,5,11,0,
        0,582,584,3,138,69,0,583,581,1,0,0,0,583,584,1,0,0,0,584,587,1,0,
        0,0,585,586,5,11,0,0,586,588,7,6,0,0,587,585,1,0,0,0,587,588,1,0,
        0,0,588,589,1,0,0,0,589,590,5,14,0,0,590,105,1,0,0,0,591,592,7,7,
        0,0,592,107,1,0,0,0,593,594,5,50,0,0,594,595,5,13,0,0,595,596,3,
        32,16,0,596,597,5,11,0,0,597,598,3,22,11,0,598,599,5,14,0,0,599,
        109,1,0,0,0,600,601,5,88,0,0,601,602,5,13,0,0,602,603,3,112,56,0,
        603,604,5,11,0,0,604,605,3,32,16,0,605,606,5,11,0,0,606,607,3,114,
        57,0,607,608,5,14,0,0,608,111,1,0,0,0,609,612,3,42,21,0,610,612,
        5,55,0,0,611,609,1,0,0,0,611,610,1,0,0,0,612,113,1,0,0,0,613,614,
        7,8,0,0,614,115,1,0,0,0,615,616,5,58,0,0,616,617,5,13,0,0,617,618,
        3,120,60,0,618,619,5,11,0,0,619,620,3,122,61,0,620,621,5,11,0,0,
        621,622,3,118,59,0,622,623,5,11,0,0,623,624,3,124,62,0,624,625,5,
        11,0,0,625,626,3,126,63,0,626,627,5,14,0,0,627,117,1,0,0,0,628,629,
        7,9,0,0,629,119,1,0,0,0,630,631,3,42,21,0,631,121,1,0,0,0,632,635,
        3,138,69,0,633,635,5,86,0,0,634,632,1,0,0,0,634,633,1,0,0,0,635,
        123,1,0,0,0,636,637,3,42,21,0,637,125,1,0,0,0,638,641,3,138,69,0,
        639,641,5,86,0,0,640,638,1,0,0,0,640,639,1,0,0,0,641,127,1,0,0,0,
        642,643,5,67,0,0,643,644,5,13,0,0,644,645,3,2,1,0,645,648,5,11,0,
        0,646,649,3,180,90,0,647,649,3,18,9,0,648,646,1,0,0,0,648,647,1,
        0,0,0,649,650,1,0,0,0,650,651,5,14,0,0,651,129,1,0,0,0,652,653,5,
        26,0,0,653,654,5,13,0,0,654,655,3,146,73,0,655,656,5,11,0,0,656,
        657,3,140,70,0,657,658,5,14,0,0,658,131,1,0,0,0,659,660,5,80,0,0,
        660,663,5,13,0,0,661,664,3,66,33,0,662,664,3,146,73,0,663,661,1,
        0,0,0,663,662,1,0,0,0,664,665,1,0,0,0,665,666,5,11,0,0,666,667,7,
        10,0,0,667,670,5,11,0,0,668,671,3,66,33,0,669,671,3,146,73,0,670,
        668,1,0,0,0,670,669,1,0,0,0,671,672,1,0,0,0,672,673,5,14,0,0,673,
        133,1,0,0,0,674,675,5,75,0,0,675,676,5,13,0,0,676,677,3,138,69,0,
        677,678,5,14,0,0,678,135,1,0,0,0,679,680,5,36,0,0,680,681,5,13,0,
        0,681,682,3,178,89,0,682,683,5,15,0,0,683,688,3,64,32,0,684,685,
        5,11,0,0,685,687,3,64,32,0,686,684,1,0,0,0,687,690,1,0,0,0,688,686,
        1,0,0,0,688,689,1,0,0,0,689,691,1,0,0,0,690,688,1,0,0,0,691,692,
        5,16,0,0,692,693,5,14,0,0,693,137,1,0,0,0,694,695,3,22,11,0,695,
        139,1,0,0,0,696,697,3,178,89,0,697,141,1,0,0,0,698,702,3,66,33,0,
        699,702,3,144,72,0,700,702,3,146,73,0,701,698,1,0,0,0,701,699,1,
        0,0,0,701,700,1,0,0,0,702,143,1,0,0,0,703,704,5,9,0,0,704,705,3,
        170,85,0,705,706,5,11,0,0,706,707,3,66,33,0,707,708,5,10,0,0,708,
        145,1,0,0,0,709,710,5,9,0,0,710,711,3,150,75,0,711,712,5,11,0,0,
        712,713,3,148,74,0,713,714,5,10,0,0,714,147,1,0,0,0,715,716,5,15,
        0,0,716,721,3,72,36,0,717,718,5,11,0,0,718,720,3,72,36,0,719,717,
        1,0,0,0,720,723,1,0,0,0,721,719,1,0,0,0,721,722,1,0,0,0,722,724,
        1,0,0,0,723,721,1,0,0,0,724,725,5,16,0,0,725,149,1,0,0,0,726,727,
        3,72,36,0,727,151,1,0,0,0,728,729,5,62,0,0,729,730,5,13,0,0,730,
        731,3,154,77,0,731,732,5,11,0,0,732,733,3,156,78,0,733,734,5,11,
        0,0,734,737,3,170,85,0,735,736,5,11,0,0,736,738,3,88,44,0,737,735,
        1,0,0,0,737,738,1,0,0,0,738,741,1,0,0,0,739,740,5,11,0,0,740,742,
        3,66,33,0,741,739,1,0,0,0,741,742,1,0,0,0,742,745,1,0,0,0,743,744,
        5,11,0,0,744,746,3,138,69,0,745,743,1,0,0,0,745,746,1,0,0,0,746,
        749,1,0,0,0,747,748,5,11,0,0,748,750,3,82,41,0,749,747,1,0,0,0,749,
        750,1,0,0,0,750,751,1,0,0,0,751,752,5,14,0,0,752,153,1,0,0,0,753,
        754,7,11,0,0,754,155,1,0,0,0,755,756,7,12,0,0,756,157,1,0,0,0,757,
        758,5,93,0,0,758,759,5,13,0,0,759,764,3,160,80,0,760,761,5,11,0,
        0,761,763,3,66,33,0,762,760,1,0,0,0,763,766,1,0,0,0,764,762,1,0,
        0,0,764,765,1,0,0,0,765,767,1,0,0,0,766,764,1,0,0,0,767,769,5,11,
        0,0,768,770,5,17,0,0,769,768,1,0,0,0,769,770,1,0,0,0,770,771,1,0,
        0,0,771,772,3,42,21,0,772,773,5,11,0,0,773,774,3,138,69,0,774,775,
        5,14,0,0,775,159,1,0,0,0,776,777,7,13,0,0,777,161,1,0,0,0,778,779,
        5,92,0,0,779,780,5,13,0,0,780,781,3,164,82,0,781,782,5,11,0,0,782,
        783,3,172,86,0,783,784,5,14,0,0,784,163,1,0,0,0,785,786,7,14,0,0,
        786,165,1,0,0,0,787,788,5,22,0,0,788,789,5,13,0,0,789,790,3,138,
        69,0,790,791,5,11,0,0,791,792,3,22,11,0,792,793,5,14,0,0,793,167,
        1,0,0,0,794,795,5,37,0,0,795,796,5,13,0,0,796,801,3,178,89,0,797,
        798,5,11,0,0,798,800,3,178,89,0,799,797,1,0,0,0,800,803,1,0,0,0,
        801,799,1,0,0,0,801,802,1,0,0,0,802,804,1,0,0,0,803,801,1,0,0,0,
        804,805,5,14,0,0,805,169,1,0,0,0,806,807,3,178,89,0,807,171,1,0,
        0,0,808,809,3,178,89,0,809,173,1,0,0,0,810,811,5,8,0,0,811,175,1,
        0,0,0,812,813,5,6,0,0,813,177,1,0,0,0,814,815,5,5,0,0,815,179,1,
        0,0,0,816,817,5,7,0,0,817,181,1,0,0,0,56,187,199,205,213,219,224,
        230,234,243,252,263,276,284,301,310,316,350,364,369,403,411,421,
        427,435,443,448,462,466,484,499,506,510,516,521,537,560,564,568,
        583,587,611,634,640,648,663,670,688,701,721,737,741,745,749,764,
        769,801
    ]

class dgdlParser ( Parser ):

    grammarFileName = "dgdl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'uri'", "'gettop'", "'getbot'", "'pop'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'<'", "'>'", "','", "':'", "'('", "')'", "'{'", "'}'", 
                     "'$'", "'&'", "'||'", "'active'", "'add'", "'assign'", 
                     "'backing'", "'backtrack'", "'complete'", "'corresponds'", 
                     "'current'", "'delete'", "'else'", "'elseif'", "'!empty'", 
                     "'empty'", "'!equal'", "'equal'", "'event'", "'extCondition'", 
                     "'extEffect'", "'extURI'", "'future'", "'greater'", 
                     "'hello'", "'id'", "'if'", "'!in'", "'in'", "'inactive'", 
                     "'incomplete'", "'initial'", "'initiate'", "'inrole'", 
                     "'inspect'", "'interaction'", "'!last'", "'last'", 
                     "'legalmoves'", "'liberal'", "'listener'", "'magnitude'", 
                     "'max'", "'maxturns'", "'min'", "'move'", "'movewise'", 
                     "'multiple'", "'next'", "'!'", "'numturns'", "'off'", 
                     "'!on'", "'on'", "'ordering'", "'owner'", "'!past'", 
                     "'past'", "'player'", "'players'", "'private'", "'public'", 
                     "'queue'", "'relation'", "'remove'", "'roles'", "'rule'", 
                     "'scope'", "'set'", "'shared'", "'single'", "'size'", 
                     "'smaller'", "'speaker'", "'stack'", "'status'", "'store'", 
                     "'strict'", "'structure'", "'terminate'", "'then'", 
                     "'!top'", "'top'", "'turns'", "'turnwise'", "'undefined'", 
                     "'visibility'", "'warrant'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "Identifier", "LowerChar", "Number", 
                      "UpperChar", "LESSTHAN", "GREATERTHAN", "COMMA", "COLON", 
                      "LPAREN", "RPAREN", "LBRACE", "RBRACE", "DOLLAR", 
                      "AND", "OR", "ACTIVE", "ADD", "ASSIGN", "BACKING", 
                      "BACKTRACK", "COMPLETE", "CORRESPONDS", "CURRENT", 
                      "DELETE", "ELSE", "ELSEIF", "NOTEMPTY", "EMPTY", "NOTEQUAL", 
                      "EQUAL", "EVENT", "EXTCONDITION", "EXTEFFECT", "EXTURI", 
                      "FUTURE", "GREATER", "HELLO", "ID", "IF", "NOTIN", 
                      "IN", "INACTIVE", "INCOMPLETE", "INITIAL", "INITIATE", 
                      "INROLE", "INSPECT", "INTERACTION", "NOTLAST", "LAST", 
                      "LEGALMOVES", "LIBERAL", "LISTENER", "MAGNITUDE", 
                      "MAX", "MAXTURNS", "MIN", "MOVE", "MOVEWISE", "MULTIPLE", 
                      "NEXT", "NOT", "NUMTURNS", "OFF", "NOTON", "ON", "ORDERING", 
                      "OWNER", "NOTPAST", "PAST", "PLAYER", "PLAYERS", "PRIVATE", 
                      "PUBLIC", "QUEUE", "RELATION", "REMOVE", "ROLES", 
                      "RULE", "SCOPE", "SET", "SHARED", "SINGLE", "SIZE", 
                      "SMALLER", "SPEAKER", "STACK", "STATUS", "STORE", 
                      "STRICT", "STRUCTURE", "TERMINATE", "THEN", "NOTTOP", 
                      "TOP", "TURNS", "TURNWISE", "UNDEFINED", "VISIBILITY", 
                      "WARRANT", "STRINGLITERAL", "SPACE", "COMMENT", "LINE_COMMENT" ]

    RULE_system = 0
    RULE_systemID = 1
    RULE_game = 2
    RULE_gameID = 3
    RULE_composition = 4
    RULE_turns = 5
    RULE_turnSize = 6
    RULE_ordering = 7
    RULE_maxTurns = 8
    RULE_runTimeVar = 9
    RULE_roleList = 10
    RULE_role = 11
    RULE_participants = 12
    RULE_minplayers = 13
    RULE_maxplayers = 14
    RULE_player = 15
    RULE_playerID = 16
    RULE_extURImap = 17
    RULE_extURIID = 18
    RULE_extURI = 19
    RULE_store = 20
    RULE_storeName = 21
    RULE_storeOwner = 22
    RULE_storeStructure = 23
    RULE_visibility = 24
    RULE_backtrack = 25
    RULE_rule = 26
    RULE_ruleID = 27
    RULE_scopeType = 28
    RULE_ruleBody = 29
    RULE_effects = 30
    RULE_effect = 31
    RULE_parameter = 32
    RULE_content = 33
    RULE_contentItem = 34
    RULE_contentSet = 35
    RULE_contentVar = 36
    RULE_contentStr = 37
    RULE_conditional = 38
    RULE_condelseif = 39
    RULE_condelse = 40
    RULE_requirements = 41
    RULE_condition = 42
    RULE_interaction = 43
    RULE_addressee = 44
    RULE_target = 45
    RULE_schemeApp = 46
    RULE_forcetarget = 47
    RULE_forceID = 48
    RULE_opener = 49
    RULE_event = 50
    RULE_eventpos = 51
    RULE_storeInspection = 52
    RULE_storepos = 53
    RULE_roleInspection = 54
    RULE_magnitude = 55
    RULE_container = 56
    RULE_containersize = 57
    RULE_storeComparison = 58
    RULE_comparison = 59
    RULE_store1 = 60
    RULE_user1 = 61
    RULE_store2 = 62
    RULE_user2 = 63
    RULE_dialogueSize = 64
    RULE_correspondence = 65
    RULE_relation = 66
    RULE_currentPlayer = 67
    RULE_externalCondition = 68
    RULE_user = 69
    RULE_schemeID = 70
    RULE_commitment = 71
    RULE_locution = 72
    RULE_argument = 73
    RULE_premises = 74
    RULE_conclusion = 75
    RULE_move = 76
    RULE_moveaction = 77
    RULE_movetime = 78
    RULE_storeOp = 79
    RULE_storeaction = 80
    RULE_statusUpdate = 81
    RULE_status = 82
    RULE_roleAssignment = 83
    RULE_externalEffect = 84
    RULE_moveID = 85
    RULE_sysgame = 86
    RULE_upperChar = 87
    RULE_lowerChar = 88
    RULE_identifier = 89
    RULE_number = 90

    ruleNames =  [ "system", "systemID", "game", "gameID", "composition", 
                   "turns", "turnSize", "ordering", "maxTurns", "runTimeVar", 
                   "roleList", "role", "participants", "minplayers", "maxplayers", 
                   "player", "playerID", "extURImap", "extURIID", "extURI", 
                   "store", "storeName", "storeOwner", "storeStructure", 
                   "visibility", "backtrack", "rule", "ruleID", "scopeType", 
                   "ruleBody", "effects", "effect", "parameter", "content", 
                   "contentItem", "contentSet", "contentVar", "contentStr", 
                   "conditional", "condelseif", "condelse", "requirements", 
                   "condition", "interaction", "addressee", "target", "schemeApp", 
                   "forcetarget", "forceID", "opener", "event", "eventpos", 
                   "storeInspection", "storepos", "roleInspection", "magnitude", 
                   "container", "containersize", "storeComparison", "comparison", 
                   "store1", "user1", "store2", "user2", "dialogueSize", 
                   "correspondence", "relation", "currentPlayer", "externalCondition", 
                   "user", "schemeID", "commitment", "locution", "argument", 
                   "premises", "conclusion", "move", "moveaction", "movetime", 
                   "storeOp", "storeaction", "statusUpdate", "status", "roleAssignment", 
                   "externalEffect", "moveID", "sysgame", "upperChar", "lowerChar", 
                   "identifier", "number" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    Identifier=5
    LowerChar=6
    Number=7
    UpperChar=8
    LESSTHAN=9
    GREATERTHAN=10
    COMMA=11
    COLON=12
    LPAREN=13
    RPAREN=14
    LBRACE=15
    RBRACE=16
    DOLLAR=17
    AND=18
    OR=19
    ACTIVE=20
    ADD=21
    ASSIGN=22
    BACKING=23
    BACKTRACK=24
    COMPLETE=25
    CORRESPONDS=26
    CURRENT=27
    DELETE=28
    ELSE=29
    ELSEIF=30
    NOTEMPTY=31
    EMPTY=32
    NOTEQUAL=33
    EQUAL=34
    EVENT=35
    EXTCONDITION=36
    EXTEFFECT=37
    EXTURI=38
    FUTURE=39
    GREATER=40
    HELLO=41
    ID=42
    IF=43
    NOTIN=44
    IN=45
    INACTIVE=46
    INCOMPLETE=47
    INITIAL=48
    INITIATE=49
    INROLE=50
    INSPECT=51
    INTERACTION=52
    NOTLAST=53
    LAST=54
    LEGALMOVES=55
    LIBERAL=56
    LISTENER=57
    MAGNITUDE=58
    MAX=59
    MAXTURNS=60
    MIN=61
    MOVE=62
    MOVEWISE=63
    MULTIPLE=64
    NEXT=65
    NOT=66
    NUMTURNS=67
    OFF=68
    NOTON=69
    ON=70
    ORDERING=71
    OWNER=72
    NOTPAST=73
    PAST=74
    PLAYER=75
    PLAYERS=76
    PRIVATE=77
    PUBLIC=78
    QUEUE=79
    RELATION=80
    REMOVE=81
    ROLES=82
    RULE=83
    SCOPE=84
    SET=85
    SHARED=86
    SINGLE=87
    SIZE=88
    SMALLER=89
    SPEAKER=90
    STACK=91
    STATUS=92
    STORE=93
    STRICT=94
    STRUCTURE=95
    TERMINATE=96
    THEN=97
    NOTTOP=98
    TOP=99
    TURNS=100
    TURNWISE=101
    UNDEFINED=102
    VISIBILITY=103
    WARRANT=104
    STRINGLITERAL=105
    SPACE=106
    COMMENT=107
    LINE_COMMENT=108

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class SystemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def systemID(self):
            return self.getTypedRuleContext(dgdlParser.SystemIDContext,0)


        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def game(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.GameContext)
            else:
                return self.getTypedRuleContext(dgdlParser.GameContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_system

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSystem" ):
                listener.enterSystem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSystem" ):
                listener.exitSystem(self)




    def system(self):

        localctx = dgdlParser.SystemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_system)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.systemID()
            self.state = 183
            self.match(dgdlParser.LBRACE)
            self.state = 185 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 184
                self.game()
                self.state = 187 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==5):
                    break

            self.state = 189
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SystemIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_systemID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSystemID" ):
                listener.enterSystemID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSystemID" ):
                listener.exitSystemID(self)




    def systemID(self):

        localctx = dgdlParser.SystemIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_systemID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gameID(self):
            return self.getTypedRuleContext(dgdlParser.GameIDContext,0)


        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def composition(self):
            return self.getTypedRuleContext(dgdlParser.CompositionContext,0)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def rule_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.RuleContext)
            else:
                return self.getTypedRuleContext(dgdlParser.RuleContext,i)


        def interaction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.InteractionContext)
            else:
                return self.getTypedRuleContext(dgdlParser.InteractionContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_game

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGame" ):
                listener.enterGame(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGame" ):
                listener.exitGame(self)




    def game(self):

        localctx = dgdlParser.GameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_game)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.gameID()
            self.state = 194
            self.match(dgdlParser.LBRACE)
            self.state = 195
            self.composition()
            self.state = 199
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==83:
                self.state = 196
                self.rule_()
                self.state = 201
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 203 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 202
                self.interaction()
                self.state = 205 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==52):
                    break

            self.state = 207
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GameIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_gameID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGameID" ):
                listener.enterGameID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGameID" ):
                listener.exitGameID(self)




    def gameID(self):

        localctx = dgdlParser.GameIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_gameID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def turns(self):
            return self.getTypedRuleContext(dgdlParser.TurnsContext,0)


        def participants(self):
            return self.getTypedRuleContext(dgdlParser.ParticipantsContext,0)


        def roleList(self):
            return self.getTypedRuleContext(dgdlParser.RoleListContext,0)


        def player(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.PlayerContext)
            else:
                return self.getTypedRuleContext(dgdlParser.PlayerContext,i)


        def extURImap(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ExtURImapContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ExtURImapContext,i)


        def store(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.StoreContext)
            else:
                return self.getTypedRuleContext(dgdlParser.StoreContext,i)


        def backtrack(self):
            return self.getTypedRuleContext(dgdlParser.BacktrackContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_composition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComposition" ):
                listener.enterComposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComposition" ):
                listener.exitComposition(self)




    def composition(self):

        localctx = dgdlParser.CompositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_composition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.turns()
            self.state = 213
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==82:
                self.state = 212
                self.roleList()


            self.state = 215
            self.participants()
            self.state = 217 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 216
                self.player()
                self.state = 219 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==75):
                    break

            self.state = 224
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==38:
                self.state = 221
                self.extURImap()
                self.state = 226
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 230
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==93:
                self.state = 227
                self.store()
                self.state = 232
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 234
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==24:
                self.state = 233
                self.backtrack()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TurnsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TURNS(self):
            return self.getToken(dgdlParser.TURNS, 0)

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def turnSize(self):
            return self.getTypedRuleContext(dgdlParser.TurnSizeContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def ordering(self):
            return self.getTypedRuleContext(dgdlParser.OrderingContext,0)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def maxTurns(self):
            return self.getTypedRuleContext(dgdlParser.MaxTurnsContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_turns

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTurns" ):
                listener.enterTurns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTurns" ):
                listener.exitTurns(self)




    def turns(self):

        localctx = dgdlParser.TurnsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_turns)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.match(dgdlParser.TURNS)
            self.state = 237
            self.match(dgdlParser.LBRACE)
            self.state = 238
            self.turnSize()
            self.state = 239
            self.match(dgdlParser.COMMA)
            self.state = 240
            self.ordering()
            self.state = 243
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 241
                self.match(dgdlParser.COMMA)
                self.state = 242
                self.maxTurns()


            self.state = 245
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TurnSizeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAGNITUDE(self):
            return self.getToken(dgdlParser.MAGNITUDE, 0)

        def COLON(self):
            return self.getToken(dgdlParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dgdlParser.NumberContext,0)


        def SINGLE(self):
            return self.getToken(dgdlParser.SINGLE, 0)

        def MULTIPLE(self):
            return self.getToken(dgdlParser.MULTIPLE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_turnSize

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTurnSize" ):
                listener.enterTurnSize(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTurnSize" ):
                listener.exitTurnSize(self)




    def turnSize(self):

        localctx = dgdlParser.TurnSizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_turnSize)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            self.match(dgdlParser.MAGNITUDE)
            self.state = 248
            self.match(dgdlParser.COLON)
            self.state = 252
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.state = 249
                self.number()
                pass
            elif token in [87]:
                self.state = 250
                self.match(dgdlParser.SINGLE)
                pass
            elif token in [64]:
                self.state = 251
                self.match(dgdlParser.MULTIPLE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDERING(self):
            return self.getToken(dgdlParser.ORDERING, 0)

        def COLON(self):
            return self.getToken(dgdlParser.COLON, 0)

        def STRICT(self):
            return self.getToken(dgdlParser.STRICT, 0)

        def LIBERAL(self):
            return self.getToken(dgdlParser.LIBERAL, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_ordering

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrdering" ):
                listener.enterOrdering(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrdering" ):
                listener.exitOrdering(self)




    def ordering(self):

        localctx = dgdlParser.OrderingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ordering)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.match(dgdlParser.ORDERING)
            self.state = 255
            self.match(dgdlParser.COLON)
            self.state = 256
            _la = self._input.LA(1)
            if not(_la==56 or _la==94):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaxTurnsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAXTURNS(self):
            return self.getToken(dgdlParser.MAXTURNS, 0)

        def COLON(self):
            return self.getToken(dgdlParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dgdlParser.NumberContext,0)


        def runTimeVar(self):
            return self.getTypedRuleContext(dgdlParser.RunTimeVarContext,0)


        def UNDEFINED(self):
            return self.getToken(dgdlParser.UNDEFINED, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_maxTurns

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxTurns" ):
                listener.enterMaxTurns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxTurns" ):
                listener.exitMaxTurns(self)




    def maxTurns(self):

        localctx = dgdlParser.MaxTurnsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_maxTurns)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self.match(dgdlParser.MAXTURNS)
            self.state = 259
            self.match(dgdlParser.COLON)
            self.state = 263
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.state = 260
                self.number()
                pass
            elif token in [17]:
                self.state = 261
                self.runTimeVar()
                pass
            elif token in [102]:
                self.state = 262
                self.match(dgdlParser.UNDEFINED)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RunTimeVarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.DOLLAR)
            else:
                return self.getToken(dgdlParser.DOLLAR, i)

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_runTimeVar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRunTimeVar" ):
                listener.enterRunTimeVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRunTimeVar" ):
                listener.exitRunTimeVar(self)




    def runTimeVar(self):

        localctx = dgdlParser.RunTimeVarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_runTimeVar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self.match(dgdlParser.DOLLAR)
            self.state = 266
            self.identifier()
            self.state = 267
            self.match(dgdlParser.DOLLAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROLES(self):
            return self.getToken(dgdlParser.ROLES, 0)

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.RoleContext)
            else:
                return self.getTypedRuleContext(dgdlParser.RoleContext,i)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def getRuleIndex(self):
            return dgdlParser.RULE_roleList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleList" ):
                listener.enterRoleList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleList" ):
                listener.exitRoleList(self)




    def roleList(self):

        localctx = dgdlParser.RoleListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_roleList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            self.match(dgdlParser.ROLES)
            self.state = 270
            self.match(dgdlParser.LBRACE)
            self.state = 271
            self.role()
            self.state = 276
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 272
                self.match(dgdlParser.COMMA)
                self.state = 273
                self.role()
                self.state = 278
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 279
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LISTENER(self):
            return self.getToken(dgdlParser.LISTENER, 0)

        def SPEAKER(self):
            return self.getToken(dgdlParser.SPEAKER, 0)

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)




    def role(self):

        localctx = dgdlParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_role)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [57]:
                self.state = 281
                self.match(dgdlParser.LISTENER)
                pass
            elif token in [90]:
                self.state = 282
                self.match(dgdlParser.SPEAKER)
                pass
            elif token in [5]:
                self.state = 283
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParticipantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLAYERS(self):
            return self.getToken(dgdlParser.PLAYERS, 0)

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def MIN(self):
            return self.getToken(dgdlParser.MIN, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COLON)
            else:
                return self.getToken(dgdlParser.COLON, i)

        def minplayers(self):
            return self.getTypedRuleContext(dgdlParser.MinplayersContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def MAX(self):
            return self.getToken(dgdlParser.MAX, 0)

        def maxplayers(self):
            return self.getTypedRuleContext(dgdlParser.MaxplayersContext,0)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_participants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParticipants" ):
                listener.enterParticipants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParticipants" ):
                listener.exitParticipants(self)




    def participants(self):

        localctx = dgdlParser.ParticipantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_participants)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.match(dgdlParser.PLAYERS)
            self.state = 287
            self.match(dgdlParser.LBRACE)
            self.state = 288
            self.match(dgdlParser.MIN)
            self.state = 289
            self.match(dgdlParser.COLON)
            self.state = 290
            self.minplayers()
            self.state = 291
            self.match(dgdlParser.COMMA)
            self.state = 292
            self.match(dgdlParser.MAX)
            self.state = 293
            self.match(dgdlParser.COLON)
            self.state = 294
            self.maxplayers()
            self.state = 295
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinplayersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(dgdlParser.NumberContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_minplayers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinplayers" ):
                listener.enterMinplayers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinplayers" ):
                listener.exitMinplayers(self)




    def minplayers(self):

        localctx = dgdlParser.MinplayersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_minplayers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaxplayersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(dgdlParser.NumberContext,0)


        def UNDEFINED(self):
            return self.getToken(dgdlParser.UNDEFINED, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_maxplayers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxplayers" ):
                listener.enterMaxplayers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxplayers" ):
                listener.exitMaxplayers(self)




    def maxplayers(self):

        localctx = dgdlParser.MaxplayersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_maxplayers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 301
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.state = 299
                self.number()
                pass
            elif token in [102]:
                self.state = 300
                self.match(dgdlParser.UNDEFINED)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlayerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLAYER(self):
            return self.getToken(dgdlParser.PLAYER, 0)

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def ID(self):
            return self.getToken(dgdlParser.ID, 0)

        def COLON(self):
            return self.getToken(dgdlParser.COLON, 0)

        def playerID(self):
            return self.getTypedRuleContext(dgdlParser.PlayerIDContext,0)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def roleList(self):
            return self.getTypedRuleContext(dgdlParser.RoleListContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_player

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlayer" ):
                listener.enterPlayer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlayer" ):
                listener.exitPlayer(self)




    def player(self):

        localctx = dgdlParser.PlayerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_player)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self.match(dgdlParser.PLAYER)
            self.state = 304
            self.match(dgdlParser.LBRACE)
            self.state = 305
            self.match(dgdlParser.ID)
            self.state = 306
            self.match(dgdlParser.COLON)
            self.state = 307
            self.playerID()
            self.state = 310
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 308
                self.match(dgdlParser.COMMA)
                self.state = 309
                self.roleList()


            self.state = 312
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlayerIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def runTimeVar(self):
            return self.getTypedRuleContext(dgdlParser.RunTimeVarContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_playerID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlayerID" ):
                listener.enterPlayerID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlayerID" ):
                listener.exitPlayerID(self)




    def playerID(self):

        localctx = dgdlParser.PlayerIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_playerID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 316
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 314
                self.identifier()
                pass
            elif token in [17]:
                self.state = 315
                self.runTimeVar()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtURImapContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTURI(self):
            return self.getToken(dgdlParser.EXTURI, 0)

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def ID(self):
            return self.getToken(dgdlParser.ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COLON)
            else:
                return self.getToken(dgdlParser.COLON, i)

        def extURIID(self):
            return self.getTypedRuleContext(dgdlParser.ExtURIIDContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def extURI(self):
            return self.getTypedRuleContext(dgdlParser.ExtURIContext,0)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_extURImap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtURImap" ):
                listener.enterExtURImap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtURImap" ):
                listener.exitExtURImap(self)




    def extURImap(self):

        localctx = dgdlParser.ExtURImapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_extURImap)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.match(dgdlParser.EXTURI)
            self.state = 319
            self.match(dgdlParser.LBRACE)
            self.state = 320
            self.match(dgdlParser.ID)
            self.state = 321
            self.match(dgdlParser.COLON)
            self.state = 322
            self.extURIID()
            self.state = 323
            self.match(dgdlParser.COMMA)
            self.state = 324
            self.match(dgdlParser.T__0)
            self.state = 325
            self.match(dgdlParser.COLON)
            self.state = 326
            self.extURI()
            self.state = 327
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtURIIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_extURIID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtURIID" ):
                listener.enterExtURIID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtURIID" ):
                listener.exitExtURIID(self)




    def extURIID(self):

        localctx = dgdlParser.ExtURIIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_extURIID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 329
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtURIContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRINGLITERAL(self):
            return self.getToken(dgdlParser.STRINGLITERAL, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_extURI

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtURI" ):
                listener.enterExtURI(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtURI" ):
                listener.exitExtURI(self)




    def extURI(self):

        localctx = dgdlParser.ExtURIContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_extURI)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 331
            self.match(dgdlParser.STRINGLITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STORE(self):
            return self.getToken(dgdlParser.STORE, 0)

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def ID(self):
            return self.getToken(dgdlParser.ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COLON)
            else:
                return self.getToken(dgdlParser.COLON, i)

        def storeName(self):
            return self.getTypedRuleContext(dgdlParser.StoreNameContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def OWNER(self):
            return self.getToken(dgdlParser.OWNER, 0)

        def storeOwner(self):
            return self.getTypedRuleContext(dgdlParser.StoreOwnerContext,0)


        def storeStructure(self):
            return self.getTypedRuleContext(dgdlParser.StoreStructureContext,0)


        def visibility(self):
            return self.getTypedRuleContext(dgdlParser.VisibilityContext,0)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ContentContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ContentContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_store

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStore" ):
                listener.enterStore(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStore" ):
                listener.exitStore(self)




    def store(self):

        localctx = dgdlParser.StoreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_store)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 333
            self.match(dgdlParser.STORE)
            self.state = 334
            self.match(dgdlParser.LBRACE)
            self.state = 335
            self.match(dgdlParser.ID)
            self.state = 336
            self.match(dgdlParser.COLON)
            self.state = 337
            self.storeName()
            self.state = 338
            self.match(dgdlParser.COMMA)
            self.state = 339
            self.match(dgdlParser.OWNER)
            self.state = 340
            self.match(dgdlParser.COLON)
            self.state = 341
            self.storeOwner()
            self.state = 342
            self.match(dgdlParser.COMMA)
            self.state = 343
            self.storeStructure()
            self.state = 344
            self.match(dgdlParser.COMMA)
            self.state = 345
            self.visibility()
            self.state = 350
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 346
                self.match(dgdlParser.COMMA)
                self.state = 347
                self.content()
                self.state = 352
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 353
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_storeName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreName" ):
                listener.enterStoreName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreName" ):
                listener.exitStoreName(self)




    def storeName(self):

        localctx = dgdlParser.StoreNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_storeName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 355
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreOwnerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def playerID(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.PlayerIDContext)
            else:
                return self.getTypedRuleContext(dgdlParser.PlayerIDContext,i)


        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def SHARED(self):
            return self.getToken(dgdlParser.SHARED, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_storeOwner

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreOwner" ):
                listener.enterStoreOwner(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreOwner" ):
                listener.exitStoreOwner(self)




    def storeOwner(self):

        localctx = dgdlParser.StoreOwnerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_storeOwner)
        self._la = 0 # Token type
        try:
            self.state = 369
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 17]:
                self.enterOuterAlt(localctx, 1)
                self.state = 357
                self.playerID()
                pass
            elif token in [15]:
                self.enterOuterAlt(localctx, 2)
                self.state = 358
                self.match(dgdlParser.LBRACE)
                self.state = 359
                self.playerID()
                self.state = 362 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 360
                    self.match(dgdlParser.COMMA)
                    self.state = 361
                    self.playerID()
                    self.state = 364 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==11):
                        break

                self.state = 366
                self.match(dgdlParser.RBRACE)
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 3)
                self.state = 368
                self.match(dgdlParser.SHARED)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreStructureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRUCTURE(self):
            return self.getToken(dgdlParser.STRUCTURE, 0)

        def COLON(self):
            return self.getToken(dgdlParser.COLON, 0)

        def SET(self):
            return self.getToken(dgdlParser.SET, 0)

        def QUEUE(self):
            return self.getToken(dgdlParser.QUEUE, 0)

        def STACK(self):
            return self.getToken(dgdlParser.STACK, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_storeStructure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreStructure" ):
                listener.enterStoreStructure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreStructure" ):
                listener.exitStoreStructure(self)




    def storeStructure(self):

        localctx = dgdlParser.StoreStructureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_storeStructure)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 371
            self.match(dgdlParser.STRUCTURE)
            self.state = 372
            self.match(dgdlParser.COLON)
            self.state = 373
            _la = self._input.LA(1)
            if not(((((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & 4161) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VISIBILITY(self):
            return self.getToken(dgdlParser.VISIBILITY, 0)

        def COLON(self):
            return self.getToken(dgdlParser.COLON, 0)

        def PUBLIC(self):
            return self.getToken(dgdlParser.PUBLIC, 0)

        def PRIVATE(self):
            return self.getToken(dgdlParser.PRIVATE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_visibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibility" ):
                listener.enterVisibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibility" ):
                listener.exitVisibility(self)




    def visibility(self):

        localctx = dgdlParser.VisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_visibility)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 375
            self.match(dgdlParser.VISIBILITY)
            self.state = 376
            self.match(dgdlParser.COLON)
            self.state = 377
            _la = self._input.LA(1)
            if not(_la==77 or _la==78):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BacktrackContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BACKTRACK(self):
            return self.getToken(dgdlParser.BACKTRACK, 0)

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def ON(self):
            return self.getToken(dgdlParser.ON, 0)

        def OFF(self):
            return self.getToken(dgdlParser.OFF, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_backtrack

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBacktrack" ):
                listener.enterBacktrack(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBacktrack" ):
                listener.exitBacktrack(self)




    def backtrack(self):

        localctx = dgdlParser.BacktrackContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_backtrack)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 379
            self.match(dgdlParser.BACKTRACK)
            self.state = 380
            self.match(dgdlParser.LBRACE)
            self.state = 381
            _la = self._input.LA(1)
            if not(_la==68 or _la==70):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 382
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RULE(self):
            return self.getToken(dgdlParser.RULE, 0)

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def ID(self):
            return self.getToken(dgdlParser.ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COLON)
            else:
                return self.getToken(dgdlParser.COLON, i)

        def ruleID(self):
            return self.getTypedRuleContext(dgdlParser.RuleIDContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def SCOPE(self):
            return self.getToken(dgdlParser.SCOPE, 0)

        def scopeType(self):
            return self.getTypedRuleContext(dgdlParser.ScopeTypeContext,0)


        def ruleBody(self):
            return self.getTypedRuleContext(dgdlParser.RuleBodyContext,0)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRule" ):
                listener.enterRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRule" ):
                listener.exitRule(self)




    def rule_(self):

        localctx = dgdlParser.RuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 384
            self.match(dgdlParser.RULE)
            self.state = 385
            self.match(dgdlParser.LBRACE)
            self.state = 386
            self.match(dgdlParser.ID)
            self.state = 387
            self.match(dgdlParser.COLON)
            self.state = 388
            self.ruleID()
            self.state = 389
            self.match(dgdlParser.COMMA)
            self.state = 390
            self.match(dgdlParser.SCOPE)
            self.state = 391
            self.match(dgdlParser.COLON)
            self.state = 392
            self.scopeType()
            self.state = 393
            self.match(dgdlParser.COMMA)
            self.state = 394
            self.ruleBody()
            self.state = 395
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_ruleID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleID" ):
                listener.enterRuleID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleID" ):
                listener.exitRuleID(self)




    def ruleID(self):

        localctx = dgdlParser.RuleIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_ruleID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 397
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopeTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INITIAL(self):
            return self.getToken(dgdlParser.INITIAL, 0)

        def TURNWISE(self):
            return self.getToken(dgdlParser.TURNWISE, 0)

        def MOVEWISE(self):
            return self.getToken(dgdlParser.MOVEWISE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_scopeType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopeType" ):
                listener.enterScopeType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopeType" ):
                listener.exitScopeType(self)




    def scopeType(self):

        localctx = dgdlParser.ScopeTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_scopeType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 399
            _la = self._input.LA(1)
            if not(((((_la - 48)) & ~0x3f) == 0 and ((1 << (_la - 48)) & 9007199254773761) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def effects(self):
            return self.getTypedRuleContext(dgdlParser.EffectsContext,0)


        def conditional(self):
            return self.getTypedRuleContext(dgdlParser.ConditionalContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_ruleBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRuleBody" ):
                listener.enterRuleBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRuleBody" ):
                listener.exitRuleBody(self)




    def ruleBody(self):

        localctx = dgdlParser.RuleBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_ruleBody)
        try:
            self.state = 403
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 401
                self.effects()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 402
                self.conditional()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EffectsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def effect(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.EffectContext)
            else:
                return self.getTypedRuleContext(dgdlParser.EffectContext,i)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.AND)
            else:
                return self.getToken(dgdlParser.AND, i)

        def getRuleIndex(self):
            return dgdlParser.RULE_effects

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEffects" ):
                listener.enterEffects(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEffects" ):
                listener.exitEffects(self)




    def effects(self):

        localctx = dgdlParser.EffectsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_effects)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 405
            self.match(dgdlParser.LBRACE)
            self.state = 406
            self.effect()
            self.state = 411
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 407
                self.match(dgdlParser.AND)
                self.state = 408
                self.effect()
                self.state = 413
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 414
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EffectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def move(self):
            return self.getTypedRuleContext(dgdlParser.MoveContext,0)


        def storeOp(self):
            return self.getTypedRuleContext(dgdlParser.StoreOpContext,0)


        def statusUpdate(self):
            return self.getTypedRuleContext(dgdlParser.StatusUpdateContext,0)


        def roleAssignment(self):
            return self.getTypedRuleContext(dgdlParser.RoleAssignmentContext,0)


        def externalEffect(self):
            return self.getTypedRuleContext(dgdlParser.ExternalEffectContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_effect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEffect" ):
                listener.enterEffect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEffect" ):
                listener.exitEffect(self)




    def effect(self):

        localctx = dgdlParser.EffectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_effect)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 421
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [62]:
                self.state = 416
                self.move()
                pass
            elif token in [93]:
                self.state = 417
                self.storeOp()
                pass
            elif token in [92]:
                self.state = 418
                self.statusUpdate()
                pass
            elif token in [22]:
                self.state = 419
                self.roleAssignment()
                pass
            elif token in [37]:
                self.state = 420
                self.externalEffect()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def contentSet(self):
            return self.getTypedRuleContext(dgdlParser.ContentSetContext,0)


        def contentVar(self):
            return self.getTypedRuleContext(dgdlParser.ContentVarContext,0)


        def HELLO(self):
            return self.getToken(dgdlParser.HELLO, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)




    def parameter(self):

        localctx = dgdlParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_parameter)
        try:
            self.state = 427
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 423
                self.identifier()
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 424
                self.contentSet()
                pass
            elif token in [6, 66]:
                self.enterOuterAlt(localctx, 3)
                self.state = 425
                self.contentVar()
                pass
            elif token in [41]:
                self.enterOuterAlt(localctx, 4)
                self.state = 426
                self.match(dgdlParser.HELLO)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def contentItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ContentItemContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ContentItemContext,i)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def getRuleIndex(self):
            return dgdlParser.RULE_content

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContent" ):
                listener.enterContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContent" ):
                listener.exitContent(self)




    def content(self):

        localctx = dgdlParser.ContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_content)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 429
            self.match(dgdlParser.LBRACE)
            self.state = 430
            self.contentItem()
            self.state = 435
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 431
                self.match(dgdlParser.COMMA)
                self.state = 432
                self.contentItem()
                self.state = 437
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 438
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContentItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def contentSet(self):
            return self.getTypedRuleContext(dgdlParser.ContentSetContext,0)


        def contentVar(self):
            return self.getTypedRuleContext(dgdlParser.ContentVarContext,0)


        def contentStr(self):
            return self.getTypedRuleContext(dgdlParser.ContentStrContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_contentItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContentItem" ):
                listener.enterContentItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContentItem" ):
                listener.exitContentItem(self)




    def contentItem(self):

        localctx = dgdlParser.ContentItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_contentItem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 443
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                self.state = 440
                self.contentSet()
                pass
            elif token in [6, 66]:
                self.state = 441
                self.contentVar()
                pass
            elif token in [105]:
                self.state = 442
                self.contentStr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContentSetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def upperChar(self):
            return self.getTypedRuleContext(dgdlParser.UpperCharContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_contentSet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContentSet" ):
                listener.enterContentSet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContentSet" ):
                listener.exitContentSet(self)




    def contentSet(self):

        localctx = dgdlParser.ContentSetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_contentSet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 445
            self.upperChar()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContentVarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lowerChar(self):
            return self.getTypedRuleContext(dgdlParser.LowerCharContext,0)


        def NOT(self):
            return self.getToken(dgdlParser.NOT, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_contentVar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContentVar" ):
                listener.enterContentVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContentVar" ):
                listener.exitContentVar(self)




    def contentVar(self):

        localctx = dgdlParser.ContentVarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_contentVar)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 448
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 447
                self.match(dgdlParser.NOT)


            self.state = 450
            self.lowerChar()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContentStrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRINGLITERAL(self):
            return self.getToken(dgdlParser.STRINGLITERAL, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_contentStr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContentStr" ):
                listener.enterContentStr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContentStr" ):
                listener.exitContentStr(self)




    def contentStr(self):

        localctx = dgdlParser.ContentStrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_contentStr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 452
            self.match(dgdlParser.STRINGLITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def IF(self):
            return self.getToken(dgdlParser.IF, 0)

        def requirements(self):
            return self.getTypedRuleContext(dgdlParser.RequirementsContext,0)


        def THEN(self):
            return self.getToken(dgdlParser.THEN, 0)

        def effects(self):
            return self.getTypedRuleContext(dgdlParser.EffectsContext,0)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def condelseif(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.CondelseifContext)
            else:
                return self.getTypedRuleContext(dgdlParser.CondelseifContext,i)


        def condelse(self):
            return self.getTypedRuleContext(dgdlParser.CondelseContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_conditional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional" ):
                listener.enterConditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional" ):
                listener.exitConditional(self)




    def conditional(self):

        localctx = dgdlParser.ConditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_conditional)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 454
            self.match(dgdlParser.LBRACE)
            self.state = 455
            self.match(dgdlParser.IF)
            self.state = 456
            self.requirements()
            self.state = 457
            self.match(dgdlParser.THEN)
            self.state = 458
            self.effects()
            self.state = 462
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==30:
                self.state = 459
                self.condelseif()
                self.state = 464
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 466
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==29:
                self.state = 465
                self.condelse()


            self.state = 468
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondelseifContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSEIF(self):
            return self.getToken(dgdlParser.ELSEIF, 0)

        def requirements(self):
            return self.getTypedRuleContext(dgdlParser.RequirementsContext,0)


        def THEN(self):
            return self.getToken(dgdlParser.THEN, 0)

        def effects(self):
            return self.getTypedRuleContext(dgdlParser.EffectsContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_condelseif

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondelseif" ):
                listener.enterCondelseif(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondelseif" ):
                listener.exitCondelseif(self)




    def condelseif(self):

        localctx = dgdlParser.CondelseifContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_condelseif)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 470
            self.match(dgdlParser.ELSEIF)
            self.state = 471
            self.requirements()
            self.state = 472
            self.match(dgdlParser.THEN)
            self.state = 473
            self.effects()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondelseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE(self):
            return self.getToken(dgdlParser.ELSE, 0)

        def effects(self):
            return self.getTypedRuleContext(dgdlParser.EffectsContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_condelse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondelse" ):
                listener.enterCondelse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondelse" ):
                listener.exitCondelse(self)




    def condelse(self):

        localctx = dgdlParser.CondelseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_condelse)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            self.match(dgdlParser.ELSE)
            self.state = 476
            self.effects()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequirementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ConditionContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ConditionContext,i)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.AND)
            else:
                return self.getToken(dgdlParser.AND, i)

        def getRuleIndex(self):
            return dgdlParser.RULE_requirements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequirements" ):
                listener.enterRequirements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequirements" ):
                listener.exitRequirements(self)




    def requirements(self):

        localctx = dgdlParser.RequirementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_requirements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 478
            self.match(dgdlParser.LBRACE)
            self.state = 479
            self.condition()
            self.state = 484
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==18:
                self.state = 480
                self.match(dgdlParser.AND)
                self.state = 481
                self.condition()
                self.state = 486
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 487
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def event(self):
            return self.getTypedRuleContext(dgdlParser.EventContext,0)


        def storeInspection(self):
            return self.getTypedRuleContext(dgdlParser.StoreInspectionContext,0)


        def roleInspection(self):
            return self.getTypedRuleContext(dgdlParser.RoleInspectionContext,0)


        def magnitude(self):
            return self.getTypedRuleContext(dgdlParser.MagnitudeContext,0)


        def storeComparison(self):
            return self.getTypedRuleContext(dgdlParser.StoreComparisonContext,0)


        def dialogueSize(self):
            return self.getTypedRuleContext(dgdlParser.DialogueSizeContext,0)


        def correspondence(self):
            return self.getTypedRuleContext(dgdlParser.CorrespondenceContext,0)


        def relation(self):
            return self.getTypedRuleContext(dgdlParser.RelationContext,0)


        def currentPlayer(self):
            return self.getTypedRuleContext(dgdlParser.CurrentPlayerContext,0)


        def externalCondition(self):
            return self.getTypedRuleContext(dgdlParser.ExternalConditionContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)




    def condition(self):

        localctx = dgdlParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_condition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 499
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [35]:
                self.state = 489
                self.event()
                pass
            elif token in [51]:
                self.state = 490
                self.storeInspection()
                pass
            elif token in [50]:
                self.state = 491
                self.roleInspection()
                pass
            elif token in [88]:
                self.state = 492
                self.magnitude()
                pass
            elif token in [58]:
                self.state = 493
                self.storeComparison()
                pass
            elif token in [67]:
                self.state = 494
                self.dialogueSize()
                pass
            elif token in [26]:
                self.state = 495
                self.correspondence()
                pass
            elif token in [80]:
                self.state = 496
                self.relation()
                pass
            elif token in [75]:
                self.state = 497
                self.currentPlayer()
                pass
            elif token in [36]:
                self.state = 498
                self.externalCondition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InteractionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERACTION(self):
            return self.getToken(dgdlParser.INTERACTION, 0)

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def moveID(self):
            return self.getTypedRuleContext(dgdlParser.MoveIDContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def ruleBody(self):
            return self.getTypedRuleContext(dgdlParser.RuleBodyContext,0)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def addressee(self):
            return self.getTypedRuleContext(dgdlParser.AddresseeContext,0)


        def target(self):
            return self.getTypedRuleContext(dgdlParser.TargetContext,0)


        def forcetarget(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ForcetargetContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ForcetargetContext,i)


        def opener(self):
            return self.getTypedRuleContext(dgdlParser.OpenerContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_interaction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInteraction" ):
                listener.enterInteraction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInteraction" ):
                listener.exitInteraction(self)




    def interaction(self):

        localctx = dgdlParser.InteractionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_interaction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 501
            self.match(dgdlParser.INTERACTION)
            self.state = 502
            self.match(dgdlParser.LBRACE)
            self.state = 503
            self.moveID()
            self.state = 506
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.state = 504
                self.match(dgdlParser.COMMA)
                self.state = 505
                self.addressee()


            self.state = 510
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.state = 508
                self.match(dgdlParser.COMMA)
                self.state = 509
                self.target()


            self.state = 516
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,32,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 512
                    self.match(dgdlParser.COMMA)
                    self.state = 513
                    self.forcetarget() 
                self.state = 518
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,32,self._ctx)

            self.state = 521
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.state = 519
                self.match(dgdlParser.COMMA)
                self.state = 520
                self.opener()


            self.state = 523
            self.match(dgdlParser.COMMA)
            self.state = 524
            self.ruleBody()
            self.state = 525
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddresseeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR(self):
            return self.getToken(dgdlParser.DOLLAR, 0)

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_addressee

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddressee" ):
                listener.enterAddressee(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddressee" ):
                listener.exitAddressee(self)




    def addressee(self):

        localctx = dgdlParser.AddresseeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_addressee)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 527
            self.match(dgdlParser.DOLLAR)
            self.state = 528
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TargetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def content(self):
            return self.getTypedRuleContext(dgdlParser.ContentContext,0)


        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def schemeApp(self):
            return self.getTypedRuleContext(dgdlParser.SchemeAppContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def schemeID(self):
            return self.getTypedRuleContext(dgdlParser.SchemeIDContext,0)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_target

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTarget" ):
                listener.enterTarget(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTarget" ):
                listener.exitTarget(self)




    def target(self):

        localctx = dgdlParser.TargetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_target)
        try:
            self.state = 537
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 530
                self.content()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 531
                self.match(dgdlParser.LBRACE)
                self.state = 532
                self.schemeApp()
                self.state = 533
                self.match(dgdlParser.COMMA)
                self.state = 534
                self.schemeID()
                self.state = 535
                self.match(dgdlParser.RBRACE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemeAppContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LESSTHAN(self):
            return self.getToken(dgdlParser.LESSTHAN, 0)

        def content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ContentContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ContentContext,i)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def GREATERTHAN(self):
            return self.getToken(dgdlParser.GREATERTHAN, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_schemeApp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchemeApp" ):
                listener.enterSchemeApp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchemeApp" ):
                listener.exitSchemeApp(self)




    def schemeApp(self):

        localctx = dgdlParser.SchemeAppContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_schemeApp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 539
            self.match(dgdlParser.LESSTHAN)
            self.state = 540
            self.content()
            self.state = 541
            self.match(dgdlParser.COMMA)
            self.state = 542
            self.content()
            self.state = 543
            self.match(dgdlParser.GREATERTHAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForcetargetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forceID(self):
            return self.getTypedRuleContext(dgdlParser.ForceIDContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def target(self):
            return self.getTypedRuleContext(dgdlParser.TargetContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_forcetarget

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForcetarget" ):
                listener.enterForcetarget(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForcetarget" ):
                listener.exitForcetarget(self)




    def forcetarget(self):

        localctx = dgdlParser.ForcetargetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_forcetarget)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 545
            self.forceID()
            self.state = 546
            self.match(dgdlParser.COMMA)
            self.state = 547
            self.target()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForceIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_forceID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForceID" ):
                listener.enterForceID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForceID" ):
                listener.exitForceID(self)




    def forceID(self):

        localctx = dgdlParser.ForceIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_forceID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 549
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OpenerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRINGLITERAL(self):
            return self.getToken(dgdlParser.STRINGLITERAL, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_opener

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpener" ):
                listener.enterOpener(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpener" ):
                listener.exitOpener(self)




    def opener(self):

        localctx = dgdlParser.OpenerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_opener)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 551
            self.match(dgdlParser.STRINGLITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT(self):
            return self.getToken(dgdlParser.EVENT, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def eventpos(self):
            return self.getTypedRuleContext(dgdlParser.EventposContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def moveID(self):
            return self.getTypedRuleContext(dgdlParser.MoveIDContext,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def content(self):
            return self.getTypedRuleContext(dgdlParser.ContentContext,0)


        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def requirements(self):
            return self.getTypedRuleContext(dgdlParser.RequirementsContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_event

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvent" ):
                listener.enterEvent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvent" ):
                listener.exitEvent(self)




    def event(self):

        localctx = dgdlParser.EventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_event)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 553
            self.match(dgdlParser.EVENT)
            self.state = 554
            self.match(dgdlParser.LPAREN)
            self.state = 555
            self.eventpos()
            self.state = 556
            self.match(dgdlParser.COMMA)
            self.state = 557
            self.moveID()
            self.state = 560
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.state = 558
                self.match(dgdlParser.COMMA)
                self.state = 559
                self.content()


            self.state = 564
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.state = 562
                self.match(dgdlParser.COMMA)
                self.state = 563
                self.user()


            self.state = 568
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 566
                self.match(dgdlParser.COMMA)
                self.state = 567
                self.requirements()


            self.state = 570
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventposContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LAST(self):
            return self.getToken(dgdlParser.LAST, 0)

        def NOTLAST(self):
            return self.getToken(dgdlParser.NOTLAST, 0)

        def PAST(self):
            return self.getToken(dgdlParser.PAST, 0)

        def NOTPAST(self):
            return self.getToken(dgdlParser.NOTPAST, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_eventpos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventpos" ):
                listener.enterEventpos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventpos" ):
                listener.exitEventpos(self)




    def eventpos(self):

        localctx = dgdlParser.EventposContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_eventpos)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 572
            _la = self._input.LA(1)
            if not(((((_la - 53)) & ~0x3f) == 0 and ((1 << (_la - 53)) & 3145731) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreInspectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSPECT(self):
            return self.getToken(dgdlParser.INSPECT, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def storepos(self):
            return self.getTypedRuleContext(dgdlParser.StoreposContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def commitment(self):
            return self.getTypedRuleContext(dgdlParser.CommitmentContext,0)


        def storeName(self):
            return self.getTypedRuleContext(dgdlParser.StoreNameContext,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def INITIAL(self):
            return self.getToken(dgdlParser.INITIAL, 0)

        def PAST(self):
            return self.getToken(dgdlParser.PAST, 0)

        def CURRENT(self):
            return self.getToken(dgdlParser.CURRENT, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_storeInspection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreInspection" ):
                listener.enterStoreInspection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreInspection" ):
                listener.exitStoreInspection(self)




    def storeInspection(self):

        localctx = dgdlParser.StoreInspectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_storeInspection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 574
            self.match(dgdlParser.INSPECT)
            self.state = 575
            self.match(dgdlParser.LPAREN)
            self.state = 576
            self.storepos()
            self.state = 577
            self.match(dgdlParser.COMMA)
            self.state = 578
            self.commitment()
            self.state = 579
            self.match(dgdlParser.COMMA)
            self.state = 580
            self.storeName()
            self.state = 583
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.state = 581
                self.match(dgdlParser.COMMA)
                self.state = 582
                self.user()


            self.state = 587
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 585
                self.match(dgdlParser.COMMA)
                self.state = 586
                _la = self._input.LA(1)
                if not(((((_la - 27)) & ~0x3f) == 0 and ((1 << (_la - 27)) & 140737490452481) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 589
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreposContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(dgdlParser.IN, 0)

        def NOTIN(self):
            return self.getToken(dgdlParser.NOTIN, 0)

        def ON(self):
            return self.getToken(dgdlParser.ON, 0)

        def NOTON(self):
            return self.getToken(dgdlParser.NOTON, 0)

        def TOP(self):
            return self.getToken(dgdlParser.TOP, 0)

        def NOTTOP(self):
            return self.getToken(dgdlParser.NOTTOP, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_storepos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStorepos" ):
                listener.enterStorepos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStorepos" ):
                listener.exitStorepos(self)




    def storepos(self):

        localctx = dgdlParser.StoreposContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_storepos)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 591
            _la = self._input.LA(1)
            if not(((((_la - 44)) & ~0x3f) == 0 and ((1 << (_la - 44)) & 54043195629109251) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleInspectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INROLE(self):
            return self.getToken(dgdlParser.INROLE, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def playerID(self):
            return self.getTypedRuleContext(dgdlParser.PlayerIDContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def role(self):
            return self.getTypedRuleContext(dgdlParser.RoleContext,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_roleInspection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleInspection" ):
                listener.enterRoleInspection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleInspection" ):
                listener.exitRoleInspection(self)




    def roleInspection(self):

        localctx = dgdlParser.RoleInspectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_roleInspection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            self.match(dgdlParser.INROLE)
            self.state = 594
            self.match(dgdlParser.LPAREN)
            self.state = 595
            self.playerID()
            self.state = 596
            self.match(dgdlParser.COMMA)
            self.state = 597
            self.role()
            self.state = 598
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MagnitudeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIZE(self):
            return self.getToken(dgdlParser.SIZE, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def container(self):
            return self.getTypedRuleContext(dgdlParser.ContainerContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def playerID(self):
            return self.getTypedRuleContext(dgdlParser.PlayerIDContext,0)


        def containersize(self):
            return self.getTypedRuleContext(dgdlParser.ContainersizeContext,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_magnitude

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMagnitude" ):
                listener.enterMagnitude(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMagnitude" ):
                listener.exitMagnitude(self)




    def magnitude(self):

        localctx = dgdlParser.MagnitudeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_magnitude)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 600
            self.match(dgdlParser.SIZE)
            self.state = 601
            self.match(dgdlParser.LPAREN)
            self.state = 602
            self.container()
            self.state = 603
            self.match(dgdlParser.COMMA)
            self.state = 604
            self.playerID()
            self.state = 605
            self.match(dgdlParser.COMMA)
            self.state = 606
            self.containersize()
            self.state = 607
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContainerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def storeName(self):
            return self.getTypedRuleContext(dgdlParser.StoreNameContext,0)


        def LEGALMOVES(self):
            return self.getToken(dgdlParser.LEGALMOVES, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_container

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContainer" ):
                listener.enterContainer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContainer" ):
                listener.exitContainer(self)




    def container(self):

        localctx = dgdlParser.ContainerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_container)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 611
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.state = 609
                self.storeName()
                pass
            elif token in [55]:
                self.state = 610
                self.match(dgdlParser.LEGALMOVES)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContainersizeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EMPTY(self):
            return self.getToken(dgdlParser.EMPTY, 0)

        def NOTEMPTY(self):
            return self.getToken(dgdlParser.NOTEMPTY, 0)

        def Number(self):
            return self.getToken(dgdlParser.Number, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_containersize

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContainersize" ):
                listener.enterContainersize(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContainersize" ):
                listener.exitContainersize(self)




    def containersize(self):

        localctx = dgdlParser.ContainersizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_containersize)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 613
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 6442451072) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreComparisonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAGNITUDE(self):
            return self.getToken(dgdlParser.MAGNITUDE, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def store1(self):
            return self.getTypedRuleContext(dgdlParser.Store1Context,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def user1(self):
            return self.getTypedRuleContext(dgdlParser.User1Context,0)


        def comparison(self):
            return self.getTypedRuleContext(dgdlParser.ComparisonContext,0)


        def store2(self):
            return self.getTypedRuleContext(dgdlParser.Store2Context,0)


        def user2(self):
            return self.getTypedRuleContext(dgdlParser.User2Context,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_storeComparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreComparison" ):
                listener.enterStoreComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreComparison" ):
                listener.exitStoreComparison(self)




    def storeComparison(self):

        localctx = dgdlParser.StoreComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_storeComparison)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 615
            self.match(dgdlParser.MAGNITUDE)
            self.state = 616
            self.match(dgdlParser.LPAREN)
            self.state = 617
            self.store1()
            self.state = 618
            self.match(dgdlParser.COMMA)
            self.state = 619
            self.user1()
            self.state = 620
            self.match(dgdlParser.COMMA)
            self.state = 621
            self.comparison()
            self.state = 622
            self.match(dgdlParser.COMMA)
            self.state = 623
            self.store2()
            self.state = 624
            self.match(dgdlParser.COMMA)
            self.state = 625
            self.user2()
            self.state = 626
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GREATER(self):
            return self.getToken(dgdlParser.GREATER, 0)

        def SMALLER(self):
            return self.getToken(dgdlParser.SMALLER, 0)

        def EQUAL(self):
            return self.getToken(dgdlParser.EQUAL, 0)

        def NOTEQUAL(self):
            return self.getToken(dgdlParser.NOTEQUAL, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)




    def comparison(self):

        localctx = dgdlParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 628
            _la = self._input.LA(1)
            if not(((((_la - 33)) & ~0x3f) == 0 and ((1 << (_la - 33)) & 72057594037928067) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Store1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def storeName(self):
            return self.getTypedRuleContext(dgdlParser.StoreNameContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_store1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStore1" ):
                listener.enterStore1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStore1" ):
                listener.exitStore1(self)




    def store1(self):

        localctx = dgdlParser.Store1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_store1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 630
            self.storeName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class User1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def SHARED(self):
            return self.getToken(dgdlParser.SHARED, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_user1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser1" ):
                listener.enterUser1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser1" ):
                listener.exitUser1(self)




    def user1(self):

        localctx = dgdlParser.User1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_user1)
        try:
            self.state = 634
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 57, 90]:
                self.enterOuterAlt(localctx, 1)
                self.state = 632
                self.user()
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 2)
                self.state = 633
                self.match(dgdlParser.SHARED)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Store2Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def storeName(self):
            return self.getTypedRuleContext(dgdlParser.StoreNameContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_store2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStore2" ):
                listener.enterStore2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStore2" ):
                listener.exitStore2(self)




    def store2(self):

        localctx = dgdlParser.Store2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_store2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 636
            self.storeName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class User2Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def SHARED(self):
            return self.getToken(dgdlParser.SHARED, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_user2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser2" ):
                listener.enterUser2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser2" ):
                listener.exitUser2(self)




    def user2(self):

        localctx = dgdlParser.User2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_user2)
        try:
            self.state = 640
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5, 57, 90]:
                self.enterOuterAlt(localctx, 1)
                self.state = 638
                self.user()
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 2)
                self.state = 639
                self.match(dgdlParser.SHARED)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DialogueSizeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMTURNS(self):
            return self.getToken(dgdlParser.NUMTURNS, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def systemID(self):
            return self.getTypedRuleContext(dgdlParser.SystemIDContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def number(self):
            return self.getTypedRuleContext(dgdlParser.NumberContext,0)


        def runTimeVar(self):
            return self.getTypedRuleContext(dgdlParser.RunTimeVarContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_dialogueSize

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDialogueSize" ):
                listener.enterDialogueSize(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDialogueSize" ):
                listener.exitDialogueSize(self)




    def dialogueSize(self):

        localctx = dgdlParser.DialogueSizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_dialogueSize)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 642
            self.match(dgdlParser.NUMTURNS)
            self.state = 643
            self.match(dgdlParser.LPAREN)
            self.state = 644
            self.systemID()
            self.state = 645
            self.match(dgdlParser.COMMA)
            self.state = 648
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.state = 646
                self.number()
                pass
            elif token in [17]:
                self.state = 647
                self.runTimeVar()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 650
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CorrespondenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CORRESPONDS(self):
            return self.getToken(dgdlParser.CORRESPONDS, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def argument(self):
            return self.getTypedRuleContext(dgdlParser.ArgumentContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def schemeID(self):
            return self.getTypedRuleContext(dgdlParser.SchemeIDContext,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_correspondence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCorrespondence" ):
                listener.enterCorrespondence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCorrespondence" ):
                listener.exitCorrespondence(self)




    def correspondence(self):

        localctx = dgdlParser.CorrespondenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_correspondence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 652
            self.match(dgdlParser.CORRESPONDS)
            self.state = 653
            self.match(dgdlParser.LPAREN)
            self.state = 654
            self.argument()
            self.state = 655
            self.match(dgdlParser.COMMA)
            self.state = 656
            self.schemeID()
            self.state = 657
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RELATION(self):
            return self.getToken(dgdlParser.RELATION, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def BACKING(self):
            return self.getToken(dgdlParser.BACKING, 0)

        def WARRANT(self):
            return self.getToken(dgdlParser.WARRANT, 0)

        def content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ContentContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ContentContext,i)


        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ArgumentContext,i)


        def getRuleIndex(self):
            return dgdlParser.RULE_relation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelation" ):
                listener.enterRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelation" ):
                listener.exitRelation(self)




    def relation(self):

        localctx = dgdlParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_relation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 659
            self.match(dgdlParser.RELATION)
            self.state = 660
            self.match(dgdlParser.LPAREN)
            self.state = 663
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                self.state = 661
                self.content()
                pass
            elif token in [9]:
                self.state = 662
                self.argument()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 665
            self.match(dgdlParser.COMMA)
            self.state = 666
            _la = self._input.LA(1)
            if not(_la==23 or _la==104):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 667
            self.match(dgdlParser.COMMA)
            self.state = 670
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                self.state = 668
                self.content()
                pass
            elif token in [9]:
                self.state = 669
                self.argument()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 672
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CurrentPlayerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLAYER(self):
            return self.getToken(dgdlParser.PLAYER, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_currentPlayer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCurrentPlayer" ):
                listener.enterCurrentPlayer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCurrentPlayer" ):
                listener.exitCurrentPlayer(self)




    def currentPlayer(self):

        localctx = dgdlParser.CurrentPlayerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_currentPlayer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 674
            self.match(dgdlParser.PLAYER)
            self.state = 675
            self.match(dgdlParser.LPAREN)
            self.state = 676
            self.user()
            self.state = 677
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExternalConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTCONDITION(self):
            return self.getToken(dgdlParser.EXTCONDITION, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ParameterContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ParameterContext,i)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def getRuleIndex(self):
            return dgdlParser.RULE_externalCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExternalCondition" ):
                listener.enterExternalCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExternalCondition" ):
                listener.exitExternalCondition(self)




    def externalCondition(self):

        localctx = dgdlParser.ExternalConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_externalCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 679
            self.match(dgdlParser.EXTCONDITION)
            self.state = 680
            self.match(dgdlParser.LPAREN)
            self.state = 681
            self.identifier()
            self.state = 682
            self.match(dgdlParser.LBRACE)
            self.state = 683
            self.parameter()
            self.state = 688
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 684
                self.match(dgdlParser.COMMA)
                self.state = 685
                self.parameter()
                self.state = 690
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 691
            self.match(dgdlParser.RBRACE)
            self.state = 692
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def role(self):
            return self.getTypedRuleContext(dgdlParser.RoleContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_user

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser" ):
                listener.enterUser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser" ):
                listener.exitUser(self)




    def user(self):

        localctx = dgdlParser.UserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_user)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 694
            self.role()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SchemeIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_schemeID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchemeID" ):
                listener.enterSchemeID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchemeID" ):
                listener.exitSchemeID(self)




    def schemeID(self):

        localctx = dgdlParser.SchemeIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_schemeID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 696
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommitmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def content(self):
            return self.getTypedRuleContext(dgdlParser.ContentContext,0)


        def locution(self):
            return self.getTypedRuleContext(dgdlParser.LocutionContext,0)


        def argument(self):
            return self.getTypedRuleContext(dgdlParser.ArgumentContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_commitment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommitment" ):
                listener.enterCommitment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommitment" ):
                listener.exitCommitment(self)




    def commitment(self):

        localctx = dgdlParser.CommitmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_commitment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 701
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.state = 698
                self.content()
                pass

            elif la_ == 2:
                self.state = 699
                self.locution()
                pass

            elif la_ == 3:
                self.state = 700
                self.argument()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocutionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LESSTHAN(self):
            return self.getToken(dgdlParser.LESSTHAN, 0)

        def moveID(self):
            return self.getTypedRuleContext(dgdlParser.MoveIDContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def content(self):
            return self.getTypedRuleContext(dgdlParser.ContentContext,0)


        def GREATERTHAN(self):
            return self.getToken(dgdlParser.GREATERTHAN, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_locution

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocution" ):
                listener.enterLocution(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocution" ):
                listener.exitLocution(self)




    def locution(self):

        localctx = dgdlParser.LocutionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_locution)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 703
            self.match(dgdlParser.LESSTHAN)
            self.state = 704
            self.moveID()
            self.state = 705
            self.match(dgdlParser.COMMA)
            self.state = 706
            self.content()
            self.state = 707
            self.match(dgdlParser.GREATERTHAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LESSTHAN(self):
            return self.getToken(dgdlParser.LESSTHAN, 0)

        def conclusion(self):
            return self.getTypedRuleContext(dgdlParser.ConclusionContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def premises(self):
            return self.getTypedRuleContext(dgdlParser.PremisesContext,0)


        def GREATERTHAN(self):
            return self.getToken(dgdlParser.GREATERTHAN, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgument" ):
                listener.enterArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgument" ):
                listener.exitArgument(self)




    def argument(self):

        localctx = dgdlParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_argument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 709
            self.match(dgdlParser.LESSTHAN)
            self.state = 710
            self.conclusion()
            self.state = 711
            self.match(dgdlParser.COMMA)
            self.state = 712
            self.premises()
            self.state = 713
            self.match(dgdlParser.GREATERTHAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PremisesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(dgdlParser.LBRACE, 0)

        def contentVar(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ContentVarContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ContentVarContext,i)


        def RBRACE(self):
            return self.getToken(dgdlParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def getRuleIndex(self):
            return dgdlParser.RULE_premises

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPremises" ):
                listener.enterPremises(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPremises" ):
                listener.exitPremises(self)




    def premises(self):

        localctx = dgdlParser.PremisesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_premises)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 715
            self.match(dgdlParser.LBRACE)
            self.state = 716
            self.contentVar()
            self.state = 721
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 717
                self.match(dgdlParser.COMMA)
                self.state = 718
                self.contentVar()
                self.state = 723
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 724
            self.match(dgdlParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConclusionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def contentVar(self):
            return self.getTypedRuleContext(dgdlParser.ContentVarContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_conclusion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConclusion" ):
                listener.enterConclusion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConclusion" ):
                listener.exitConclusion(self)




    def conclusion(self):

        localctx = dgdlParser.ConclusionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_conclusion)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 726
            self.contentVar()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MOVE(self):
            return self.getToken(dgdlParser.MOVE, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def moveaction(self):
            return self.getTypedRuleContext(dgdlParser.MoveactionContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def movetime(self):
            return self.getTypedRuleContext(dgdlParser.MovetimeContext,0)


        def moveID(self):
            return self.getTypedRuleContext(dgdlParser.MoveIDContext,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def addressee(self):
            return self.getTypedRuleContext(dgdlParser.AddresseeContext,0)


        def content(self):
            return self.getTypedRuleContext(dgdlParser.ContentContext,0)


        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def requirements(self):
            return self.getTypedRuleContext(dgdlParser.RequirementsContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_move

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMove" ):
                listener.enterMove(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMove" ):
                listener.exitMove(self)




    def move(self):

        localctx = dgdlParser.MoveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_move)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 728
            self.match(dgdlParser.MOVE)
            self.state = 729
            self.match(dgdlParser.LPAREN)
            self.state = 730
            self.moveaction()
            self.state = 731
            self.match(dgdlParser.COMMA)
            self.state = 732
            self.movetime()
            self.state = 733
            self.match(dgdlParser.COMMA)
            self.state = 734
            self.moveID()
            self.state = 737
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.state = 735
                self.match(dgdlParser.COMMA)
                self.state = 736
                self.addressee()


            self.state = 741
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                self.state = 739
                self.match(dgdlParser.COMMA)
                self.state = 740
                self.content()


            self.state = 745
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.state = 743
                self.match(dgdlParser.COMMA)
                self.state = 744
                self.user()


            self.state = 749
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 747
                self.match(dgdlParser.COMMA)
                self.state = 748
                self.requirements()


            self.state = 751
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoveactionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(dgdlParser.ADD, 0)

        def DELETE(self):
            return self.getToken(dgdlParser.DELETE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_moveaction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMoveaction" ):
                listener.enterMoveaction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMoveaction" ):
                listener.exitMoveaction(self)




    def moveaction(self):

        localctx = dgdlParser.MoveactionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_moveaction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 753
            _la = self._input.LA(1)
            if not(_la==21 or _la==28):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MovetimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEXT(self):
            return self.getToken(dgdlParser.NEXT, 0)

        def FUTURE(self):
            return self.getToken(dgdlParser.FUTURE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_movetime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMovetime" ):
                listener.enterMovetime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMovetime" ):
                listener.exitMovetime(self)




    def movetime(self):

        localctx = dgdlParser.MovetimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_movetime)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 755
            _la = self._input.LA(1)
            if not(_la==39 or _la==65):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STORE(self):
            return self.getToken(dgdlParser.STORE, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def storeaction(self):
            return self.getTypedRuleContext(dgdlParser.StoreactionContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def storeName(self):
            return self.getTypedRuleContext(dgdlParser.StoreNameContext,0)


        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def content(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.ContentContext)
            else:
                return self.getTypedRuleContext(dgdlParser.ContentContext,i)


        def DOLLAR(self):
            return self.getToken(dgdlParser.DOLLAR, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_storeOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreOp" ):
                listener.enterStoreOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreOp" ):
                listener.exitStoreOp(self)




    def storeOp(self):

        localctx = dgdlParser.StoreOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_storeOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 757
            self.match(dgdlParser.STORE)
            self.state = 758
            self.match(dgdlParser.LPAREN)
            self.state = 759
            self.storeaction()
            self.state = 764
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,53,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 760
                    self.match(dgdlParser.COMMA)
                    self.state = 761
                    self.content() 
                self.state = 766
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,53,self._ctx)

            self.state = 767
            self.match(dgdlParser.COMMA)
            self.state = 769
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==17:
                self.state = 768
                self.match(dgdlParser.DOLLAR)


            self.state = 771
            self.storeName()
            self.state = 772
            self.match(dgdlParser.COMMA)
            self.state = 773
            self.user()
            self.state = 774
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreactionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(dgdlParser.ADD, 0)

        def REMOVE(self):
            return self.getToken(dgdlParser.REMOVE, 0)

        def EMPTY(self):
            return self.getToken(dgdlParser.EMPTY, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_storeaction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStoreaction" ):
                listener.enterStoreaction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStoreaction" ):
                listener.exitStoreaction(self)




    def storeaction(self):

        localctx = dgdlParser.StoreactionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_storeaction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 776
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 4297064476) != 0) or _la==81):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusUpdateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STATUS(self):
            return self.getToken(dgdlParser.STATUS, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def status(self):
            return self.getTypedRuleContext(dgdlParser.StatusContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def sysgame(self):
            return self.getTypedRuleContext(dgdlParser.SysgameContext,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_statusUpdate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatusUpdate" ):
                listener.enterStatusUpdate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatusUpdate" ):
                listener.exitStatusUpdate(self)




    def statusUpdate(self):

        localctx = dgdlParser.StatusUpdateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_statusUpdate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 778
            self.match(dgdlParser.STATUS)
            self.state = 779
            self.match(dgdlParser.LPAREN)
            self.state = 780
            self.status()
            self.state = 781
            self.match(dgdlParser.COMMA)
            self.state = 782
            self.sysgame()
            self.state = 783
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACTIVE(self):
            return self.getToken(dgdlParser.ACTIVE, 0)

        def INACTIVE(self):
            return self.getToken(dgdlParser.INACTIVE, 0)

        def COMPLETE(self):
            return self.getToken(dgdlParser.COMPLETE, 0)

        def INCOMPLETE(self):
            return self.getToken(dgdlParser.INCOMPLETE, 0)

        def INITIATE(self):
            return self.getToken(dgdlParser.INITIATE, 0)

        def TERMINATE(self):
            return self.getToken(dgdlParser.TERMINATE, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_status

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatus" ):
                listener.enterStatus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatus" ):
                listener.exitStatus(self)




    def status(self):

        localctx = dgdlParser.StatusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_status)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 785
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 774056220557312) != 0) or _la==96):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSIGN(self):
            return self.getToken(dgdlParser.ASSIGN, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def user(self):
            return self.getTypedRuleContext(dgdlParser.UserContext,0)


        def COMMA(self):
            return self.getToken(dgdlParser.COMMA, 0)

        def role(self):
            return self.getTypedRuleContext(dgdlParser.RoleContext,0)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_roleAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoleAssignment" ):
                listener.enterRoleAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoleAssignment" ):
                listener.exitRoleAssignment(self)




    def roleAssignment(self):

        localctx = dgdlParser.RoleAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_roleAssignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 787
            self.match(dgdlParser.ASSIGN)
            self.state = 788
            self.match(dgdlParser.LPAREN)
            self.state = 789
            self.user()
            self.state = 790
            self.match(dgdlParser.COMMA)
            self.state = 791
            self.role()
            self.state = 792
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExternalEffectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTEFFECT(self):
            return self.getToken(dgdlParser.EXTEFFECT, 0)

        def LPAREN(self):
            return self.getToken(dgdlParser.LPAREN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dgdlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(dgdlParser.IdentifierContext,i)


        def RPAREN(self):
            return self.getToken(dgdlParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dgdlParser.COMMA)
            else:
                return self.getToken(dgdlParser.COMMA, i)

        def getRuleIndex(self):
            return dgdlParser.RULE_externalEffect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExternalEffect" ):
                listener.enterExternalEffect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExternalEffect" ):
                listener.exitExternalEffect(self)




    def externalEffect(self):

        localctx = dgdlParser.ExternalEffectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_externalEffect)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 794
            self.match(dgdlParser.EXTEFFECT)
            self.state = 795
            self.match(dgdlParser.LPAREN)
            self.state = 796
            self.identifier()
            self.state = 801
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 797
                self.match(dgdlParser.COMMA)
                self.state = 798
                self.identifier()
                self.state = 803
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 804
            self.match(dgdlParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoveIDContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_moveID

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMoveID" ):
                listener.enterMoveID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMoveID" ):
                listener.exitMoveID(self)




    def moveID(self):

        localctx = dgdlParser.MoveIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_moveID)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 806
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SysgameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dgdlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return dgdlParser.RULE_sysgame

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSysgame" ):
                listener.enterSysgame(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSysgame" ):
                listener.exitSysgame(self)




    def sysgame(self):

        localctx = dgdlParser.SysgameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_sysgame)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 808
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpperCharContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UpperChar(self):
            return self.getToken(dgdlParser.UpperChar, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_upperChar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpperChar" ):
                listener.enterUpperChar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpperChar" ):
                listener.exitUpperChar(self)




    def upperChar(self):

        localctx = dgdlParser.UpperCharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_upperChar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 810
            self.match(dgdlParser.UpperChar)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LowerCharContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LowerChar(self):
            return self.getToken(dgdlParser.LowerChar, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_lowerChar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLowerChar" ):
                listener.enterLowerChar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLowerChar" ):
                listener.exitLowerChar(self)




    def lowerChar(self):

        localctx = dgdlParser.LowerCharContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_lowerChar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            self.match(dgdlParser.LowerChar)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(dgdlParser.Identifier, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = dgdlParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 814
            self.match(dgdlParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Number(self):
            return self.getToken(dgdlParser.Number, 0)

        def getRuleIndex(self):
            return dgdlParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)




    def number(self):

        localctx = dgdlParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 816
            self.match(dgdlParser.Number)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





